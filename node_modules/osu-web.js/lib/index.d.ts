import { z } from 'zod';
import { AxiosInstance } from 'axios';

declare class Base$1 {
    protected clientId: number;
    protected clientSecret: string;
    protected redirectUri: string;
    protected oauthUrl: string;
    protected headers: {
        headers: {
            'Accept-Encoding': string;
        };
    };
    constructor(clientId: number, clientSecret: string, redirectUri: string);
}

declare enum ModesEnum {
    osu = 0,
    taiko = 1,
    fruits = 2,
    mania = 3
}
declare enum StatusEnum {
    graveyard = -2,
    wip = -1,
    pending = 0,
    ranked = 1,
    approved = 2,
    qualified = 3,
    loved = 4
}
declare enum GenresEnum {
    Any = 0,
    Unspecified = 1,
    'Video Game' = 2,
    Anime = 3,
    Rock = 4,
    Pop = 5,
    Other = 6,
    Novelty = 7,
    'Hip Hop' = 9,
    Electronic = 10,
    Metal = 11,
    Classical = 12,
    Folk = 13,
    Jazz = 14
}
declare enum LanguagesEnum {
    Any = 0,
    Unspecified = 1,
    English = 2,
    Japanese = 3,
    Chinese = 4,
    Instrumental = 5,
    Korean = 6,
    French = 7,
    German = 8,
    Swedish = 9,
    Spanish = 10,
    Italian = 11,
    Russian = 12,
    Polish = 13,
    Other = 14
}
declare enum ModsEnum {
    NF = 1,
    EZ = 2,
    TD = 4,
    HD = 8,
    HR = 16,
    SD = 32,
    DT = 64,
    RX = 128,
    HT = 256,
    NC = 512,
    FL = 1024,
    AT = 2048,
    SO = 4096,
    AP = 8192,
    PF = 16384,
    K4 = 32768,
    K5 = 65536,
    K6 = 131072,
    K7 = 262144,
    K8 = 524288,
    FI = 1048576,
    RN = 2097152,
    CN = 4194304,
    TR = 8388608,
    K9 = 16777216,
    KC = 33554432,
    K1 = 67108864,
    K3 = 134217728,
    K2 = 268435456,
    SV2 = 536870912,
    MR = 1073741824
}
declare enum ScoringTypeEnum {
    Score = 0,
    Accuracy = 1,
    Combo = 2,
    'Score V2' = 3
}
declare enum TeamTypeEnum {
    'Head To Head' = 0,
    'Tag Co-Op' = 1,
    'Team VS' = 2,
    'Tag Team VS' = 3
}
declare enum TeamColorEnum {
    Blue = 1,
    Red = 2
}

declare const gameModeSchema: z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>;
declare const searchOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        mode: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"all">, z.ZodLiteral<"user">, z.ZodLiteral<"wiki_page">]>>;
        query: z.ZodOptional<z.ZodString>;
        page: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        query?: string | undefined;
        mode?: "all" | "user" | "wiki_page" | undefined;
        page?: number | undefined;
    }, {
        query?: string | undefined;
        mode?: "all" | "user" | "wiki_page" | undefined;
        page?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        query?: string | undefined;
        mode?: "all" | "user" | "wiki_page" | undefined;
        page?: number | undefined;
    } | undefined;
}, {
    query?: {
        query?: string | undefined;
        mode?: "all" | "user" | "wiki_page" | undefined;
        page?: number | undefined;
    } | undefined;
}>;

declare const getSelfOptionsSchema: z.ZodObject<{
    urlParams: z.ZodOptional<z.ZodObject<{
        mode: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    }, "strip", z.ZodTypeAny, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    }, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    urlParams?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    } | undefined;
}, {
    urlParams?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    } | undefined;
}>;
declare const getUserKudosuOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        offset: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        limit?: number | undefined;
        offset?: number | undefined;
    }, {
        limit?: number | undefined;
        offset?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}, {
    query?: {
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}>;
declare const userScoreTypeSchema: z.ZodUnion<[z.ZodLiteral<"best">, z.ZodLiteral<"firsts">, z.ZodLiteral<"recent">]>;
declare const getUserScoresOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        mode: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
        limit: z.ZodOptional<z.ZodNumber>;
        offset: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
    }, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}, {
    query?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}>;
declare const getUserRecentScoresOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        include_fails: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodNumber]>>;
        mode: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
        limit: z.ZodOptional<z.ZodNumber>;
        offset: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
        include_fails?: number | boolean | undefined;
    }, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
        include_fails?: number | boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
        include_fails?: number | boolean | undefined;
    } | undefined;
}, {
    query?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
        limit?: number | undefined;
        offset?: number | undefined;
        include_fails?: number | boolean | undefined;
    } | undefined;
}>;
declare const getUserBeatmapsOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        offset: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        limit?: number | undefined;
        offset?: number | undefined;
    }, {
        limit?: number | undefined;
        offset?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}, {
    query?: {
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}>;
declare const userBeatmapsTypeSchema: z.ZodUnion<[z.ZodLiteral<"favourite">, z.ZodLiteral<"graveyard">, z.ZodLiteral<"guest">, z.ZodLiteral<"loved">, z.ZodLiteral<"most_played">, z.ZodLiteral<"nominated">, z.ZodLiteral<"pending">, z.ZodLiteral<"ranked">]>;
declare const getUserRecentActivityOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        offset: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        limit?: number | undefined;
        offset?: number | undefined;
    }, {
        limit?: number | undefined;
        offset?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}, {
    query?: {
        limit?: number | undefined;
        offset?: number | undefined;
    } | undefined;
}>;
declare const getUserOptionsSchema: z.ZodObject<{
    urlParams: z.ZodOptional<z.ZodObject<{
        mode: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    }, "strip", z.ZodTypeAny, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    }, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    }>>;
    query: z.ZodOptional<z.ZodObject<{
        key: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"id">, z.ZodLiteral<"username">]>>;
    }, "strip", z.ZodTypeAny, {
        key?: "id" | "username" | undefined;
    }, {
        key?: "id" | "username" | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        key?: "id" | "username" | undefined;
    } | undefined;
    urlParams?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    } | undefined;
}, {
    query?: {
        key?: "id" | "username" | undefined;
    } | undefined;
    urlParams?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    } | undefined;
}>;
declare const getUsersOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        ids: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
    }, "strip", z.ZodTypeAny, {
        ids?: number[] | undefined;
    }, {
        ids?: number[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        ids?: number[] | undefined;
    } | undefined;
}, {
    query?: {
        ids?: number[] | undefined;
    } | undefined;
}>;

declare const commentSortSchema: z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">, z.ZodLiteral<"top">]>;
declare const commentableTypeSchema: z.ZodUnion<[z.ZodLiteral<"beatmapset">, z.ZodLiteral<"news_post">, z.ZodLiteral<"build">]>;
declare const getCommentsOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        commentable: z.ZodOptional<z.ZodObject<{
            type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"beatmapset">, z.ZodLiteral<"news_post">, z.ZodLiteral<"build">]>>;
            id: z.ZodOptional<z.ZodNumber>;
        }, "strip", z.ZodTypeAny, {
            type?: "beatmapset" | "news_post" | "build" | undefined;
            id?: number | undefined;
        }, {
            type?: "beatmapset" | "news_post" | "build" | undefined;
            id?: number | undefined;
        }>>;
        parent_id: z.ZodOptional<z.ZodNumber>;
        sort: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"new">, z.ZodLiteral<"old">, z.ZodLiteral<"top">]>>;
    }, "strip", z.ZodTypeAny, {
        sort?: "new" | "old" | "top" | undefined;
        commentable?: {
            type?: "beatmapset" | "news_post" | "build" | undefined;
            id?: number | undefined;
        } | undefined;
        parent_id?: number | undefined;
    }, {
        sort?: "new" | "old" | "top" | undefined;
        commentable?: {
            type?: "beatmapset" | "news_post" | "build" | undefined;
            id?: number | undefined;
        } | undefined;
        parent_id?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        sort?: "new" | "old" | "top" | undefined;
        commentable?: {
            type?: "beatmapset" | "news_post" | "build" | undefined;
            id?: number | undefined;
        } | undefined;
        parent_id?: number | undefined;
    } | undefined;
}, {
    query?: {
        sort?: "new" | "old" | "top" | undefined;
        commentable?: {
            type?: "beatmapset" | "news_post" | "build" | undefined;
            id?: number | undefined;
        } | undefined;
        parent_id?: number | undefined;
    } | undefined;
}>;

declare const multiplayerScoresSortSchema: z.ZodUnion<[z.ZodLiteral<"score_asc">, z.ZodLiteral<"score_desc">]>;
declare const getPlaylistScoresOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        sort: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"score_asc">, z.ZodLiteral<"score_desc">]>>;
        cursor_string: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        sort?: "score_asc" | "score_desc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
    }, {
        sort?: "score_asc" | "score_desc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        sort?: "score_asc" | "score_desc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
    } | undefined;
}, {
    query?: {
        sort?: "score_asc" | "score_desc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
    } | undefined;
}>;

declare const rankingTypeSchema: z.ZodUnion<[z.ZodLiteral<"charts">, z.ZodLiteral<"country">, z.ZodLiteral<"performance">, z.ZodLiteral<"score">]>;
declare const getRankingOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        country: z.ZodOptional<z.ZodEffects<z.ZodString, string, string>>;
        filter: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"all">, z.ZodLiteral<"friends">]>>;
        spotlight: z.ZodOptional<z.ZodNumber>;
        variant: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        filter?: "all" | "friends" | undefined;
        country?: string | undefined;
        spotlight?: number | undefined;
        variant?: string | undefined;
    }, {
        filter?: "all" | "friends" | undefined;
        country?: string | undefined;
        spotlight?: number | undefined;
        variant?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        filter?: "all" | "friends" | undefined;
        country?: string | undefined;
        spotlight?: number | undefined;
        variant?: string | undefined;
    } | undefined;
}, {
    query?: {
        filter?: "all" | "friends" | undefined;
        country?: string | undefined;
        spotlight?: number | undefined;
        variant?: string | undefined;
    } | undefined;
}>;

declare const changelogStreamSchema: z.ZodUnion<[z.ZodLiteral<"stable40">, z.ZodLiteral<"beta40">, z.ZodLiteral<"cuttingedge">, z.ZodLiteral<"lazer">, z.ZodLiteral<"web">]>;
declare const getChangelogListingOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        from: z.ZodOptional<z.ZodString>;
        max_id: z.ZodOptional<z.ZodNumber>;
        stream: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"stable40">, z.ZodLiteral<"beta40">, z.ZodLiteral<"cuttingedge">, z.ZodLiteral<"lazer">, z.ZodLiteral<"web">]>>;
        to: z.ZodOptional<z.ZodString>;
        message_formats: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"html">, z.ZodLiteral<"markdown">]>, "many">>;
    }, "strip", z.ZodTypeAny, {
        from?: string | undefined;
        max_id?: number | undefined;
        stream?: "stable40" | "beta40" | "cuttingedge" | "lazer" | "web" | undefined;
        to?: string | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    }, {
        from?: string | undefined;
        max_id?: number | undefined;
        stream?: "stable40" | "beta40" | "cuttingedge" | "lazer" | "web" | undefined;
        to?: string | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        from?: string | undefined;
        max_id?: number | undefined;
        stream?: "stable40" | "beta40" | "cuttingedge" | "lazer" | "web" | undefined;
        to?: string | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    } | undefined;
}, {
    query?: {
        from?: string | undefined;
        max_id?: number | undefined;
        stream?: "stable40" | "beta40" | "cuttingedge" | "lazer" | "web" | undefined;
        to?: string | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    } | undefined;
}>;
declare const lookupChangelogBuildOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        key: z.ZodOptional<z.ZodLiteral<"id">>;
        message_formats: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"html">, z.ZodLiteral<"markdown">]>, "many">>;
    }, "strip", z.ZodTypeAny, {
        key?: "id" | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    }, {
        key?: "id" | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        key?: "id" | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    } | undefined;
}, {
    query?: {
        key?: "id" | undefined;
        message_formats?: ("html" | "markdown")[] | undefined;
    } | undefined;
}>;

declare const getDiscussionPostsOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        beatmapset_discussion_id: z.ZodOptional<z.ZodNumber>;
        types: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"first">, z.ZodLiteral<"reply">, z.ZodLiteral<"system">]>, "many">>;
        user: z.ZodOptional<z.ZodNumber>;
        limit: z.ZodOptional<z.ZodNumber>;
        page: z.ZodOptional<z.ZodNumber>;
        sort: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"id_desc">, z.ZodLiteral<"id_asc">]>>;
    }, "strip", z.ZodTypeAny, {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmapset_discussion_id?: number | undefined;
        types?: ("first" | "reply" | "system")[] | undefined;
    }, {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmapset_discussion_id?: number | undefined;
        types?: ("first" | "reply" | "system")[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmapset_discussion_id?: number | undefined;
        types?: ("first" | "reply" | "system")[] | undefined;
    } | undefined;
}, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmapset_discussion_id?: number | undefined;
        types?: ("first" | "reply" | "system")[] | undefined;
    } | undefined;
}>;
declare const getDiscussionVotesOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        beatmapset_discussion_id: z.ZodOptional<z.ZodNumber>;
        receiver: z.ZodOptional<z.ZodNumber>;
        score: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<1>, z.ZodLiteral<-1>]>>;
        user: z.ZodOptional<z.ZodNumber>;
        limit: z.ZodOptional<z.ZodNumber>;
        page: z.ZodOptional<z.ZodNumber>;
        sort: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"id_desc">, z.ZodLiteral<"id_asc">]>>;
    }, "strip", z.ZodTypeAny, {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        score?: 1 | -1 | undefined;
        beatmapset_discussion_id?: number | undefined;
        receiver?: number | undefined;
    }, {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        score?: 1 | -1 | undefined;
        beatmapset_discussion_id?: number | undefined;
        receiver?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        score?: 1 | -1 | undefined;
        beatmapset_discussion_id?: number | undefined;
        receiver?: number | undefined;
    } | undefined;
}, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        score?: 1 | -1 | undefined;
        beatmapset_discussion_id?: number | undefined;
        receiver?: number | undefined;
    } | undefined;
}>;
declare const discussionMessageTypeSchema: z.ZodUnion<[z.ZodLiteral<"suggestion">, z.ZodLiteral<"problem">, z.ZodLiteral<"mapper_note">, z.ZodLiteral<"praise">, z.ZodLiteral<"hype">, z.ZodLiteral<"review">]>;
declare const getDiscussionsOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        beatmap_id: z.ZodOptional<z.ZodNumber>;
        beatmapset_id: z.ZodOptional<z.ZodNumber>;
        beatmapset_status: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"all">, z.ZodLiteral<"ranked">, z.ZodLiteral<"qualified">, z.ZodLiteral<"disqualified">, z.ZodLiteral<"never_qualified">]>>;
        message_types: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"suggestion">, z.ZodLiteral<"problem">, z.ZodLiteral<"mapper_note">, z.ZodLiteral<"praise">, z.ZodLiteral<"hype">, z.ZodLiteral<"review">]>, "many">>;
        only_unresolved: z.ZodOptional<z.ZodBoolean>;
        user: z.ZodOptional<z.ZodNumber>;
        limit: z.ZodOptional<z.ZodNumber>;
        page: z.ZodOptional<z.ZodNumber>;
        sort: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"id_desc">, z.ZodLiteral<"id_asc">]>>;
    }, "strip", z.ZodTypeAny, {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmap_id?: number | undefined;
        beatmapset_id?: number | undefined;
        beatmapset_status?: "all" | "ranked" | "qualified" | "disqualified" | "never_qualified" | undefined;
        message_types?: ("suggestion" | "problem" | "mapper_note" | "praise" | "hype" | "review")[] | undefined;
        only_unresolved?: boolean | undefined;
    }, {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmap_id?: number | undefined;
        beatmapset_id?: number | undefined;
        beatmapset_status?: "all" | "ranked" | "qualified" | "disqualified" | "never_qualified" | undefined;
        message_types?: ("suggestion" | "problem" | "mapper_note" | "praise" | "hype" | "review")[] | undefined;
        only_unresolved?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmap_id?: number | undefined;
        beatmapset_id?: number | undefined;
        beatmapset_status?: "all" | "ranked" | "qualified" | "disqualified" | "never_qualified" | undefined;
        message_types?: ("suggestion" | "problem" | "mapper_note" | "praise" | "hype" | "review")[] | undefined;
        only_unresolved?: boolean | undefined;
    } | undefined;
}, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        user?: number | undefined;
        page?: number | undefined;
        limit?: number | undefined;
        beatmap_id?: number | undefined;
        beatmapset_id?: number | undefined;
        beatmapset_status?: "all" | "ranked" | "qualified" | "disqualified" | "never_qualified" | undefined;
        message_types?: ("suggestion" | "problem" | "mapper_note" | "praise" | "hype" | "review")[] | undefined;
        only_unresolved?: boolean | undefined;
    } | undefined;
}>;

/**
 * Timestamp string in ISO 8601 format
 */
type ISOTimestamp = string;
type Cursor = string | null;
type Mod = keyof typeof ModsEnum;
type RankStatus = keyof typeof StatusEnum;
type GameMode = z.infer<typeof gameModeSchema>;
type UserBeatmapsType = z.infer<typeof userBeatmapsTypeSchema>;
type CommentableType = z.infer<typeof commentableTypeSchema>;
type CommentSort = z.infer<typeof commentSortSchema>;
type MultiplayerScoresSort = z.infer<typeof multiplayerScoresSortSchema>;
type RankingType = z.infer<typeof rankingTypeSchema>;
type UserScoreType = z.infer<typeof userScoreTypeSchema>;
type ChangelogStream = z.infer<typeof changelogStreamSchema>;
type DiscussionMessageType = z.infer<typeof discussionMessageTypeSchema>;
type Playstyle = 'mouse' | 'keyboard' | 'tablet' | 'touch';
type Scope = 'chat.write' | 'delegate' | 'forum.write' | 'friends.read' | 'identify' | 'public';
type ProfilePageSection = 'me' | 'recent_activity' | 'beatmaps' | 'historical' | 'kudosu' | 'top_ranks' | 'medals';
type UserAccountHistoryType = 'note' | 'restriction' | 'silence';
type KudosuAction = 'give' | 'vote.give' | 'reset' | 'vote.reset' | 'revoke' | 'vote.revoke';
type Rank = 'SS' | 'SSH' | 'S' | 'SH' | 'A' | 'B' | 'C' | 'D' | 'F';
type UserEventType = 'achievement' | 'beatmapPlaycount' | 'beatmapsetApprove' | 'beatmapsetDelete' | 'beatmapsetRevive' | 'beatmapsetUpdate' | 'beatmapsetUpload' | 'rank' | 'rankLost' | 'userSupportAgain' | 'userSupportFirst' | 'userSupportGift' | 'usernameChange';
type AchievementGrouping = 'Skill' | 'Hush-Hush' | 'Dedication' | 'Mod Introduction';
type EventBeatmapsetApprovedType = 'ranked' | 'approved' | 'qualified' | 'loved';
type SpotlightType = 'monthly' | 'spotlight' | 'theme' | 'special' | 'bestof';
type ChannelType = 'PUBLIC' | 'PRIVATE' | 'MULTIPLAYER' | 'SPECTATOR' | 'TEMPORARY' | 'PM' | 'GROUP' | 'ANNOUNCE';
type ChatMessageType = 'action' | 'markdown' | 'plain';
type ForumTopicType = 'normal' | 'sticky' | 'announcement';
interface Token {
    token_type: string;
    expires_in: number;
    access_token: string;
    refresh_token: string;
}
type GuestToken = Omit<Token, 'refresh_token'>;
interface UserCompact {
    avatar_url: string;
    country_code: string;
    default_group: string;
    id: number;
    is_active: boolean;
    is_bot: boolean;
    is_deleted: boolean;
    is_online: boolean;
    is_supporter: boolean;
    last_visit: string;
    pm_friends_only: boolean;
    profile_colour: string | null;
    username: string;
}
interface Country {
    code: string;
    name: string;
}
interface Cover {
    custom_url: string | null;
    url: string;
    id: string | null;
}
interface UserKudosu {
    available: number;
    total: number;
}
interface User extends UserCompact {
    country: Country;
    cover: Cover;
    discord: string | null;
    has_supported: boolean;
    interests: string | null;
    join_date: ISOTimestamp;
    kudosu: UserKudosu;
    location: string | null;
    max_blocks: number;
    max_friends: number;
    occupation: string | null;
    playmode: GameMode;
    playstyle: Playstyle[];
    post_count: number;
    profile_order: ProfilePageSection[];
    title: string | null;
    title_url: string | null;
    twitter: string | null;
    website: string | null;
}
interface UserAccountHistory {
    description: string | null;
    id: number;
    length: number;
    permanent: boolean;
    timestamp: string;
    type: UserAccountHistoryType;
}
interface UserActiveTournamentBanner {
    id: number;
    tournament_id: number;
    image: string;
}
interface UserBadge {
    awarded_at: ISOTimestamp;
    description: string;
    image_url: string;
    url: string;
}
interface Page {
    html: string;
    raw: string;
}
interface Group {
    colour: string | null;
    has_listing: boolean;
    has_playmodes: boolean;
    id: number;
    identifier: string;
    is_probationary: boolean;
    name: string;
    short_name: string;
}
interface UserGroup extends Group {
    playmodes: GameMode[] | null;
}
interface MonthlyPlaycount {
    start_date: ISOTimestamp;
    count: number;
}
interface RankHighest {
    rank: number;
    updated_at: ISOTimestamp;
}
interface RankHistory {
    mode: GameMode;
    data: number[];
}
interface GradeCounts {
    a: number;
    s: number;
    sh: number;
    ss: number;
    ssh: number;
}
interface UserLevel {
    current: number;
    progress: number;
}
interface UserStatistics {
    grade_counts: GradeCounts;
    hit_accuracy: number;
    is_ranked: boolean;
    level: UserLevel;
    maximum_combo: number;
    play_count: number;
    play_time: number;
    pp: number;
    global_rank: number;
    ranked_score: number;
    replays_watched_by_others: number;
    total_hits: number;
    total_score: number;
    country_rank: number;
}
interface UserAchievement {
    achieved_at: ISOTimestamp;
    achievement_id: number;
}
interface UserExtended extends User {
    account_history: UserAccountHistory[];
    active_tournament_banner: UserActiveTournamentBanner | null;
    badges: UserBadge[];
    beatmap_playcounts_count: number;
    favourite_beatmapset_count: number;
    follower_count: number;
    graveyard_beatmapset_count: number;
    groups: UserGroup[];
    loved_beatmapset_count: number;
    mapping_follower_count: number;
    monthly_playcounts: MonthlyPlaycount[];
    page: Page;
    pending_beatmapset_count: number;
    previous_usernames: string[];
    rank_highest: RankHighest | null;
    rank_history: RankHistory;
    ranked_beatmapset_count: number;
    replays_watched_counts: MonthlyPlaycount[];
    scores_best_count: number;
    scores_first_count: number;
    scores_recent_count: number;
    statistics: UserStatistics;
    support_level: number;
    user_achievements: UserAchievement[];
}
interface Giver {
    url: string;
    username: string;
}
interface Post {
    url: string | null;
    title: string;
}
interface UserKudosuHistory {
    id: number;
    action: KudosuAction;
    amount: number;
    model: string;
    created_at: ISOTimestamp;
    giver: Giver | null;
    post: Post;
}
type StatisticsRulesets = Record<GameMode, UserStatistics | undefined>;
interface BeatmapCompact {
    beatmapset_id: number;
    difficulty_rating: number;
    id: number;
    mode: GameMode;
    status: RankStatus;
    total_length: number;
    user_id: number;
    version: string;
}
interface ScoreStatistics {
    count_50: number;
    count_100: number;
    count_300: number;
    count_geki: number;
    count_katu: number;
    count_miss: number;
}
interface Score {
    id: number;
    user_id: number;
    accuracy: number;
    mods: Mod[];
    score: number;
    max_combo: number;
    perfect: boolean;
    statistics: ScoreStatistics;
    passed: boolean;
    pp: number;
    rank: Rank;
    created_at: ISOTimestamp;
    mode: GameMode;
    mode_int: number;
    replay: boolean;
}
interface Covers {
    'cover': string;
    'cover@2x': string;
    'card': string;
    'card@2x': string;
    'list': string;
    'list@2x': string;
    'slimcover': string;
    'slimcover@2x': string;
}
interface BeatmapsetCompact {
    artist: string;
    artist_unicode: string;
    covers: Covers;
    creator: string;
    favourite_count: number;
    id: number;
    nsfw: boolean;
    play_count: number;
    preview_url: string;
    source: string;
    status: RankStatus;
    title: string;
    title_unicode: string;
    user_id: string;
    video: boolean;
}
interface UserScore extends Score {
    beatmap: BeatmapCompact & {
        checksum: string | null;
    };
    beatmapset: BeatmapsetCompact;
    user: UserCompact;
}
interface Weight {
    percentage: number;
    pp: number;
}
interface UserBestScore extends UserScore, Score {
    weight: Weight;
}
interface BeatmapsetAvailability {
    download_disabled: boolean;
    more_information: string | null;
}
interface BeatmapsetHype {
    current: number;
    required: number;
}
interface Beatmapset extends BeatmapsetCompact {
    availability: BeatmapsetAvailability;
    bpm: number;
    can_be_hyped: boolean;
    creator: string;
    discussion_locked: boolean;
    hype: BeatmapsetHype | null;
    is_scoreable: boolean;
    last_updated: ISOTimestamp;
    legacy_thread_url: string | null;
    nominations_summary: BeatmapsetHype;
    ranked: number;
    ranked_date: ISOTimestamp | null;
    source: string;
    storyboard: boolean;
    submitted_date: ISOTimestamp | null;
    tags: string;
}
interface Beatmap extends BeatmapCompact {
    accuracy: number;
    ar: number;
    beatmapset_id: number;
    bpm: number | null;
    convert: boolean;
    count_circles: number;
    count_sliders: number;
    count_spinners: number;
    cs: number;
    deleted_at: ISOTimestamp | null;
    drain: number;
    hit_length: number;
    is_scoreable: boolean;
    last_updated: ISOTimestamp;
    mode_int: number;
    passcount: number;
    playcount: number;
    ranked: number;
    url: string;
}
interface BeatmapPlaycount {
    beatmap_id: number;
    beatmap: BeatmapCompact | null;
    beatmapset: BeatmapsetCompact | null;
    count: number;
}
interface EventAchievement {
    icon_url: string;
    id: number;
    name: string;
    grouping: AchievementGrouping;
    ordering: number;
    slug: string;
    description: string;
    mode: GameMode | null;
    instructions: string;
}
interface EventUser {
    username: string;
    url: string;
}
interface EventBeatmap {
    title: string;
    url: string;
}
interface BaseUserEvent {
    created_at: ISOTimestamp;
    id: number;
    type: UserEventType;
}
interface UserEventAchievement extends BaseUserEvent {
    type: 'achievement';
    achievement: EventAchievement;
    user: EventUser;
}
interface UserEventBeatmapPlaycount extends BaseUserEvent {
    type: 'beatmapPlaycount';
    beatmap: EventBeatmap;
    count: number;
}
interface UserEventBeatmapsetApprove extends BaseUserEvent {
    type: 'beatmapsetApprove';
    approval: EventBeatmapsetApprovedType;
    beatmapset: EventBeatmap;
}
interface UserEventBeatmapsetDelete extends BaseUserEvent {
    type: 'beatmapsetDelete';
    beatmapset: EventBeatmap;
}
interface UserEventBeatmapsetUpdate extends BaseUserEvent {
    type: 'beatmapsetRevive' | 'beatmapsetUpdate' | 'beatmapsetUpload';
    beatmapset: EventBeatmap;
    user: EventUser;
}
interface UserEventRank extends BaseUserEvent {
    mode: GameMode;
    beatmap: EventBeatmap;
    user: EventUser;
}
interface UserEventRankAchieved extends BaseUserEvent, UserEventRank {
    type: 'rank';
    scoreRank: Rank;
}
interface UserEventRankLost extends BaseUserEvent, UserEventRank {
    type: 'rankLost';
}
interface UserEventUserUpdate extends BaseUserEvent {
    type: 'userSupportAgain' | 'userSupportFirst' | 'userSupportGift';
    user: EventUser;
}
interface UserEventUsernameUpdate extends BaseUserEvent {
    type: 'usernameChange';
    user: EventUser & {
        previousUsername: string | null;
    };
}
type UserEvent = UserEventAchievement | UserEventBeatmapPlaycount | UserEventBeatmapsetApprove | UserEventBeatmapsetDelete | UserEventBeatmapsetUpdate | UserEventRankAchieved | UserEventRankLost | UserEventUserUpdate | UserEventUsernameUpdate;
interface WikiPage {
    available_locales: string[];
    layout: string;
    locale: string;
    markdown: string;
    path: string;
    subtitle: string | null;
    tags: string[];
    title: string;
}
type SearchResult<T> = {
    data: T[];
    total: number;
};
interface SearchResults {
    user: SearchResult<UserCompact> | null;
    wiki_page: SearchResult<WikiPage> | null;
}
interface CommentableMetadata {
    id: number;
    title: string;
    type: string;
    url: string;
}
interface Comment {
    commentable_id: number;
    commentable_type: CommentableType;
    created_at: ISOTimestamp;
    deleted_at: ISOTimestamp | null;
    edited_at: ISOTimestamp | null;
    edited_by_id: number | null;
    id: number;
    legacy_name: string | null;
    message: string | null;
    message_html: string | null;
    parent_id: number | null;
    pinned: boolean;
    replies_count: number;
    updated_at: ISOTimestamp;
    user_id: number;
    votes_count: number;
}
interface CommentBundle {
    commentable_meta: CommentableMetadata[];
    comments: Comment[];
    has_more: boolean;
    has_more_id: number | null;
    included_comments: Comment[];
    pinned_commnets: Comment[] | null;
    sort: CommentSort;
    top_level_count: number | null;
    total: number | null;
    user_follow: boolean;
    user_votes: number[];
    users: UserCompact[];
}
interface MultiplayerScoresParams {
    limit: number;
    sort: MultiplayerScoresSort;
}
interface MultiplayerScoreMod {
    acronym: Mod;
}
interface MultiplayerScoreStatistics {
    Ok: number;
    Meh: number;
    Good: number;
    Miss: number;
    None: number;
    Great: number;
    Perfect: number;
    IgnoreHit: number;
    IgnoreMiss: number;
    LargeBonus: number;
    SmallBonus: number;
    LargeTickHit: number;
    SmallTickHit: number;
    LargeTickMiss: number;
    SmallTickMiss: number;
}
interface MultiplayerScore {
    id: number;
    user_id: number;
    room_id: number;
    playlist_item_id: number;
    beatmap_id: number;
    rank: Rank;
    total_score: number;
    accuracy: number;
    max_combo: number;
    mods: MultiplayerScoreMod[];
    statistics: MultiplayerScoreStatistics;
    passed: boolean;
    position: number | null;
    user: UserCompact & {
        country: Country;
        cover: Cover;
    };
}
interface MultiplayerScores {
    cursor_string: Cursor;
    params: MultiplayerScoresParams;
    scores: MultiplayerScore[];
    total: number | null;
    user_score: MultiplayerScore | null;
}
interface Spotlight {
    end_date: ISOTimestamp;
    id: number;
    mode_specific: boolean;
    participant_count: number | null;
    name: string;
    start_date: ISOTimestamp;
    type: SpotlightType;
}
interface Rankings {
    beatmapsets: Beatmapset[] | null;
    ranking: (UserStatistics & {
        user: UserCompact & {
            country: Country;
            cover: Cover;
        };
    })[];
    spotlight: Spotlight | null;
    total: number;
}
interface NewsPost {
    author: string;
    edit_url: string;
    first_image: string | null;
    id: number;
    published_at: ISOTimestamp;
    slug: string;
    title: string;
    updated_at: ISOTimestamp;
}
interface NewsSidebar {
    current_year: number;
    news_posts: NewsPost;
    years: number[];
}
interface NewsSearch {
    limit: number;
    sort: 'published_desc';
}
interface NewsListing {
    cursor_string: Cursor;
    news_posts: NewsPost & {
        preview: string;
    };
    news_sidebar: NewsSidebar;
    search: NewsSearch;
}
interface NewsNavigation {
    newer: NewsPost | null;
    older: NewsPost | null;
}
interface Fails {
    exit: number[] | null;
    fail: number[] | null;
}
interface BeatmapUserScore {
    position: number;
    score: Score & {
        beatmap: Beatmap & {
            checksum: string | null;
        };
        user: UserCompact & {
            country: Country;
            cover: Cover;
        };
    };
}
interface BeatmapDifficultyAttributes {
    max_combo: number;
    star_rating: number;
    gamemode: GameMode;
}
interface OsuBeatmapDifficultyAttributes extends BeatmapDifficultyAttributes {
    gamemode: 'osu';
    aim_difficulty: number;
    approach_rate: number;
    flashlight_difficulty: number;
    overall_difficulty: number;
    slider_factor: number;
    speed_difficulty: number;
}
interface TaikoBeatmapDifficultyAttributes extends BeatmapDifficultyAttributes {
    gamemode: 'taiko';
    stamina_difficulty: number;
    rhythm_difficulty: number;
    colour_difficulty: number;
    approach_rate: number;
    great_hit_window: number;
}
interface FruitsBeatmapDifficultyAttributes extends BeatmapDifficultyAttributes {
    gamemode: 'fruits';
    approach_rate: number;
}
interface ManiaBeatmapDifficultyAttributes extends BeatmapDifficultyAttributes {
    gamemode: 'mania';
    great_hit_window: number;
    score_multiplier: number;
}
interface UpdateStream {
    display_name: string | null;
    id: number;
    is_featured: boolean;
    name: string;
}
interface Build {
    created_at: ISOTimestamp;
    display_version: string;
    id: number;
    update_stream: UpdateStream | null;
    users: number;
    version: string | null;
}
interface BuildVersions {
    next: Build | null;
    previous: Build | null;
}
interface ChangelogEntry {
    category: string;
    created_at: ISOTimestamp | null;
    github_pull_request_id: number | null;
    github_url: string | null;
    id: number | null;
    major: boolean;
    repository: string | null;
    title: string | null;
    type: string;
    url: string | null;
}
interface GithubUser {
    display_name: string;
    github_url: string | null;
    id: number | null;
    osu_username: string | null;
    user_id: number | null;
    user_url: string | null;
}
interface Channel {
    channel_id: number;
    name: string;
    description: string | null;
    icon: string | null;
    type: ChannelType;
    moderated: boolean;
    uuid: string | null;
}
interface ChatMessage {
    channel_id: number;
    content: string;
    is_action: boolean;
    message_id: number;
    sender_id: number;
    timestamp: ISOTimestamp;
    type: ChatMessageType;
    uuid: string | null;
}
interface ForumPost {
    created_at: ISOTimestamp;
    deleted_at: ISOTimestamp | null;
    edited_at: ISOTimestamp | null;
    edited_by_id: number | null;
    forum_id: number;
    id: number;
    topic_id: number;
    user_id: number;
}
interface ForumPostBody {
    html: string;
    raw: string;
}
interface ForumTopic {
    created_at: ISOTimestamp;
    deleted_at: ISOTimestamp | null;
    first_post_id: number;
    forum_id: number;
    id: number;
    is_locked: boolean;
    last_post_id: number;
    poll: ForumPoll | null;
    post_count: number;
    title: string;
    type: ForumTopicType;
    updated_at: ISOTimestamp;
    user_id: number;
}
interface ForumPoll {
    allow_vote_change: boolean;
    ended_at: ISOTimestamp | null;
    hide_incomplete_results: boolean;
    last_vote_at: ISOTimestamp | null;
    max_votes: number;
    options: ForumPollOptions[];
    started_at: ISOTimestamp;
    title: {
        bbcode: string;
        html: string;
    };
    total_vote_count: number;
}
interface ForumPollOptions {
    id: number;
    text: {
        bbcode: string;
        html: string;
    };
    vote_count: number | null;
}
interface BeatmapsetDiscussion {
    beatmap_id: number | null;
    beatmapset_id: number | null;
    can_be_resolved: boolean;
    can_grant_kudosu: boolean;
    created_at: ISOTimestamp;
    deleted_at: ISOTimestamp | null;
    deleted_by_id: number | null;
    id: number;
    kudosu_denied: boolean;
    last_post_at: ISOTimestamp;
    message_type: DiscussionMessageType;
    parent_id: number | null;
    resolved: boolean;
    timestamp: number | null;
    updated_at: ISOTimestamp;
    user_id: number;
}
interface DiscussionPost {
    beatmapset_discussion_id: number;
    created_at: ISOTimestamp;
    deleted_at: ISOTimestamp | null;
    deleted_by_id: number | null;
    id: number;
    last_editor_id: number | null;
    message: string;
    system: boolean;
    updated_at: ISOTimestamp;
    user_id: number;
}
interface DiscussionVote {
    beatmapset_discussion_id: number;
    created_at: ISOTimestamp;
    id: number;
    score: number;
    updated_at: ISOTimestamp;
    user_id: number;
}

/**
 * Class that handles auth code grant flow related actions
 */
declare class AuthCodeGrant extends Base$1 {
    private scopes;
    /**
     * @param clientId OAuth client ID
     * @param clientSecret OAuth client secret
     * @param redirectUri OAuth redirect URI
     * @param scopes An array of OAuth scopes
     */
    constructor(clientId: number, clientSecret: string, redirectUri: string, scopes: Scope[]);
    /**
     * Gets a token
     * @param code The string received after a user authorizes the app
     * @returns An API token
     */
    requestToken(code: string): Promise<Token>;
    /**
     * Refreshes a token
     * @param refreshToken The token used to refresh
     * @returns An API token
     */
    refreshToken(refreshToken: string): Promise<Token>;
}

/**
 * Class that wraps all OAuth related endpoints
 */
declare class Auth extends Base$1 {
    /**
     * @param clientId OAuth client ID
     * @param clientSecret OAuth client secret
     * @param redirectUri OAuth redirect URI
     */
    constructor(clientId: number, clientSecret: string, redirectUri: string);
    /**
     * @param scopes An array of scopes
     */
    authorizationCodeGrant(scopes?: Scope[]): AuthCodeGrant;
    /**
     * Gets a token
     * @returns An API token (with guest permissions)
     */
    clientCredentialsGrant(): Promise<GuestToken>;
    /**
     * Revokes a token
     * @param accessToken Access toke to revoke
     */
    revokeToken(accessToken: string): Promise<void>;
}

declare const lookupBeatmapOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        checksum: z.ZodOptional<z.ZodString>;
        filename: z.ZodOptional<z.ZodString>;
        id: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        id?: number | undefined;
        checksum?: string | undefined;
        filename?: string | undefined;
    }, {
        id?: number | undefined;
        checksum?: string | undefined;
        filename?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        id?: number | undefined;
        checksum?: string | undefined;
        filename?: string | undefined;
    } | undefined;
}, {
    query?: {
        id?: number | undefined;
        checksum?: string | undefined;
        filename?: string | undefined;
    } | undefined;
}>;
declare const getBeatmapScoresOptionSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        mode: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    }, "strip", z.ZodTypeAny, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    }, {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    } | undefined;
}, {
    query?: {
        mode?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    } | undefined;
}>;
declare const getBeatmapsOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        ids: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
    }, "strip", z.ZodTypeAny, {
        ids?: number[] | undefined;
    }, {
        ids?: number[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        ids?: number[] | undefined;
    } | undefined;
}, {
    query?: {
        ids?: number[] | undefined;
    } | undefined;
}>;
declare const getBeatmapOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        id: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        id?: number | undefined;
    }, {
        id?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        id?: number | undefined;
    } | undefined;
}, {
    query?: {
        id?: number | undefined;
    } | undefined;
}>;
declare const getBeatmapAttributesOptionsSchema: z.ZodObject<{
    body: z.ZodOptional<z.ZodObject<{
        mods: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodArray<z.ZodUnion<[z.ZodLiteral<"NF">, z.ZodLiteral<"EZ">, z.ZodLiteral<"TD">, z.ZodLiteral<"HD">, z.ZodLiteral<"HR">, z.ZodLiteral<"SD">, z.ZodLiteral<"DT">, z.ZodLiteral<"RX">, z.ZodLiteral<"HT">, z.ZodLiteral<"NC">, z.ZodLiteral<"FL">, z.ZodLiteral<"AT">, z.ZodLiteral<"SO">, z.ZodLiteral<"AP">, z.ZodLiteral<"PF">, z.ZodLiteral<"FI">, z.ZodLiteral<"RN">, z.ZodLiteral<"CN">, z.ZodLiteral<"TR">, z.ZodLiteral<"KC">, z.ZodLiteral<"SV2">, z.ZodLiteral<"MR">, z.ZodLiteral<"K1">, z.ZodLiteral<"K2">, z.ZodLiteral<"K3">, z.ZodLiteral<"K4">, z.ZodLiteral<"K5">, z.ZodLiteral<"K6">, z.ZodLiteral<"K7">, z.ZodLiteral<"K8">, z.ZodLiteral<"K9">]>, "many">]>>;
    }, "strip", z.ZodTypeAny, {
        mods?: number | ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    }, {
        mods?: number | ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    body?: {
        mods?: number | ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    } | undefined;
}, {
    body?: {
        mods?: number | ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    } | undefined;
}>;

declare const createPMOptionsSchema: z.ZodObject<{
    body: z.ZodObject<{
        /** ID of the user to send a PM */
        target_id: z.ZodNumber;
        /** Message to send */
        message: z.ZodString;
        /** Is the message an action? */
        is_action: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
        /** Client side message identifier which will be sent back in response and websocket JSON */
        uuid: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        is_action?: boolean | undefined;
        uuid?: string | undefined;
        message: string;
        target_id: number;
    }, {
        is_action?: boolean | undefined;
        uuid?: string | undefined;
        message: string;
        target_id: number;
    }>;
}, "strip", z.ZodTypeAny, {
    body: {
        is_action?: boolean | undefined;
        uuid?: string | undefined;
        message: string;
        target_id: number;
    };
}, {
    body: {
        is_action?: boolean | undefined;
        uuid?: string | undefined;
        message: string;
        target_id: number;
    };
}>;
declare const createPMChannelOptionsSchema: z.ZodObject<{
    body: z.ZodObject<{
        /** Message to send */
        message: z.ZodOptional<z.ZodString>;
        /** Channel details */
        channel: z.ZodOptional<z.ZodObject<{
            name: z.ZodOptional<z.ZodString>;
            description: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            name?: string | undefined;
            description?: string | undefined;
        }, {
            name?: string | undefined;
            description?: string | undefined;
        }>>;
        /** Target user ID */
        target_id: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        message?: string | undefined;
        channel?: {
            name?: string | undefined;
            description?: string | undefined;
        } | undefined;
        target_id: number;
    }, {
        message?: string | undefined;
        channel?: {
            name?: string | undefined;
            description?: string | undefined;
        } | undefined;
        target_id: number;
    }>;
}, "strip", z.ZodTypeAny, {
    body: {
        message?: string | undefined;
        channel?: {
            name?: string | undefined;
            description?: string | undefined;
        } | undefined;
        target_id: number;
    };
}, {
    body: {
        message?: string | undefined;
        channel?: {
            name?: string | undefined;
            description?: string | undefined;
        } | undefined;
        target_id: number;
    };
}>;
declare const createAnnounceChannelOptionsSchema: z.ZodObject<{
    body: z.ZodObject<{
        /** Message to send with the announcement */
        message: z.ZodString;
        /** Channel details */
        channel: z.ZodObject<{
            /** Channel name */
            name: z.ZodString;
            /** Channel description */
            description: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            name: string;
            description: string;
        }, {
            name: string;
            description: string;
        }>;
        /** Target user IDs */
        target_ids: z.ZodArray<z.ZodNumber, "many">;
    }, "strip", z.ZodTypeAny, {
        message: string;
        channel: {
            name: string;
            description: string;
        };
        target_ids: number[];
    }, {
        message: string;
        channel: {
            name: string;
            description: string;
        };
        target_ids: number[];
    }>;
}, "strip", z.ZodTypeAny, {
    body: {
        message: string;
        channel: {
            name: string;
            description: string;
        };
        target_ids: number[];
    };
}, {
    body: {
        message: string;
        channel: {
            name: string;
            description: string;
        };
        target_ids: number[];
    };
}>;

declare const replyToTopicOptionsSchema: z.ZodObject<{
    body: z.ZodObject<{
        /** Content of the reply */
        body: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        body: string;
    }, {
        body: string;
    }>;
}, "strip", z.ZodTypeAny, {
    body: {
        body: string;
    };
}, {
    body: {
        body: string;
    };
}>;
declare const createTopicOptionsSchema: z.ZodObject<{
    body: z.ZodObject<{
        /** Content of the topic */
        body: z.ZodString;
        /** ID of the forum to create the topic in */
        forum_id: z.ZodNumber;
        /** Title of the topic */
        title: z.ZodString;
        /** Create a poll with the topic? */
        with_poll: z.ZodOptional<z.ZodBoolean>;
        /** Poll details */
        forum_topic_poll: z.ZodOptional<z.ZodObject<{
            /** Hide result (until voting period ends)? */
            hide_results: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
            /** Length of the voting period in days. 0 means that the voting will never end. This parameter is required if `hide_results` option is enabled */
            length_days: z.ZodOptional<z.ZodDefault<z.ZodNumber>>;
            /** Max. number of votes each user can cast */
            max_options: z.ZodOptional<z.ZodDefault<z.ZodNumber>>;
            /** Newline-separated list of voting options. BBCode is supported */
            options: z.ZodString;
            /** Title of the poll */
            title: z.ZodString;
            /** Can a user change their votes? */
            vote_change: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
        }, "strip", z.ZodTypeAny, {
            hide_results?: boolean | undefined;
            length_days?: number | undefined;
            max_options?: number | undefined;
            vote_change?: boolean | undefined;
            options: string;
            title: string;
        }, {
            hide_results?: boolean | undefined;
            length_days?: number | undefined;
            max_options?: number | undefined;
            vote_change?: boolean | undefined;
            options: string;
            title: string;
        }>>;
    }, "strip", z.ZodTypeAny, {
        with_poll?: boolean | undefined;
        forum_topic_poll?: {
            hide_results?: boolean | undefined;
            length_days?: number | undefined;
            max_options?: number | undefined;
            vote_change?: boolean | undefined;
            options: string;
            title: string;
        } | undefined;
        body: string;
        forum_id: number;
        title: string;
    }, {
        with_poll?: boolean | undefined;
        forum_topic_poll?: {
            hide_results?: boolean | undefined;
            length_days?: number | undefined;
            max_options?: number | undefined;
            vote_change?: boolean | undefined;
            options: string;
            title: string;
        } | undefined;
        body: string;
        forum_id: number;
        title: string;
    }>;
}, "strip", z.ZodTypeAny, {
    body: {
        with_poll?: boolean | undefined;
        forum_topic_poll?: {
            hide_results?: boolean | undefined;
            length_days?: number | undefined;
            max_options?: number | undefined;
            vote_change?: boolean | undefined;
            options: string;
            title: string;
        } | undefined;
        body: string;
        forum_id: number;
        title: string;
    };
}, {
    body: {
        with_poll?: boolean | undefined;
        forum_topic_poll?: {
            hide_results?: boolean | undefined;
            length_days?: number | undefined;
            max_options?: number | undefined;
            vote_change?: boolean | undefined;
            options: string;
            title: string;
        } | undefined;
        body: string;
        forum_id: number;
        title: string;
    };
}>;
declare const getTopicOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        cursor_string: z.ZodOptional<z.ZodString>;
        sort: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"id_asc">, z.ZodLiteral<"id_desc">]>>;
        limit: z.ZodOptional<z.ZodNumber>;
        start: z.ZodOptional<z.ZodNumber>;
        end: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        sort?: "id_desc" | "id_asc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
        start?: number | undefined;
        end?: number | undefined;
    }, {
        sort?: "id_desc" | "id_asc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
        start?: number | undefined;
        end?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
        start?: number | undefined;
        end?: number | undefined;
    } | undefined;
}, {
    query?: {
        sort?: "id_desc" | "id_asc" | undefined;
        limit?: number | undefined;
        cursor_string?: string | undefined;
        start?: number | undefined;
        end?: number | undefined;
    } | undefined;
}>;
declare const updateTopicOptionsSchema: z.ZodObject<{
    body: z.ZodOptional<z.ZodObject<{
        forum_topic: z.ZodOptional<z.ZodObject<{
            topic_title: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            topic_title?: string | undefined;
        }, {
            topic_title?: string | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        forum_topic?: {
            topic_title?: string | undefined;
        } | undefined;
    }, {
        forum_topic?: {
            topic_title?: string | undefined;
        } | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    body?: {
        forum_topic?: {
            topic_title?: string | undefined;
        } | undefined;
    } | undefined;
}, {
    body?: {
        forum_topic?: {
            topic_title?: string | undefined;
        } | undefined;
    } | undefined;
}>;
declare const updatePostOptionsSchema: z.ZodObject<{
    body: z.ZodObject<{
        /** Content of the post in BBCode format */
        body: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        body: string;
    }, {
        body: string;
    }>;
}, "strip", z.ZodTypeAny, {
    body: {
        body: string;
    };
}, {
    body: {
        body: string;
    };
}>;

declare const getNewsListingOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        year: z.ZodOptional<z.ZodNumber>;
        cursor_string: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        limit?: number | undefined;
        cursor_string?: string | undefined;
        year?: number | undefined;
    }, {
        limit?: number | undefined;
        cursor_string?: string | undefined;
        year?: number | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        limit?: number | undefined;
        cursor_string?: string | undefined;
        year?: number | undefined;
    } | undefined;
}, {
    query?: {
        limit?: number | undefined;
        cursor_string?: string | undefined;
        year?: number | undefined;
    } | undefined;
}>;
declare const getNewsPostOptionsSchema: z.ZodObject<{
    query: z.ZodOptional<z.ZodObject<{
        key: z.ZodOptional<z.ZodLiteral<"id">>;
    }, "strip", z.ZodTypeAny, {
        key?: "id" | undefined;
    }, {
        key?: "id" | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    query?: {
        key?: "id" | undefined;
    } | undefined;
}, {
    query?: {
        key?: "id" | undefined;
    } | undefined;
}>;

interface Options {
    query?: Record<string, unknown>;
    body?: Record<string, unknown> | string;
}
type LookupBeatmapOptions = z.infer<typeof lookupBeatmapOptionsSchema>;
type GetBeatmapScoresOptions = z.infer<typeof getBeatmapScoresOptionSchema>;
type GetBeatmapsOptions = z.infer<typeof getBeatmapsOptionsSchema>;
type GetBeatmapOptions = z.infer<typeof getBeatmapOptionsSchema>;
type GetBeatmapAttributesOptions = z.infer<typeof getBeatmapAttributesOptionsSchema>;
type GetDiscussionPostsOptions = z.infer<typeof getDiscussionPostsOptionsSchema>;
type GetDiscussionVotesOptions = z.infer<typeof getDiscussionVotesOptionsSchema>;
type GetDiscussionsOptions = z.infer<typeof getDiscussionsOptionsSchema>;
type GetChangelogListingOptions = z.infer<typeof getChangelogListingOptionsSchema>;
type LookupChangelogBuildOptions = z.infer<typeof lookupChangelogBuildOptionsSchema>;
type CreatePMOptions = z.infer<typeof createPMOptionsSchema>;
type CreatePMChannelOptions = z.infer<typeof createPMChannelOptionsSchema>;
type CreateAnnounceChannelOptions = z.infer<typeof createAnnounceChannelOptionsSchema>;
type GetCommentsOptions = z.infer<typeof getCommentsOptionsSchema>;
type ReplyToTopicOptions = z.infer<typeof replyToTopicOptionsSchema>;
type CreateTopicOptions = z.infer<typeof createTopicOptionsSchema>;
type GetTopicOptions = z.infer<typeof getTopicOptionsSchema>;
type UpdateTopicOptions = z.infer<typeof updateTopicOptionsSchema>;
type UpdatePostOptions = z.infer<typeof updatePostOptionsSchema>;
type SearchOptions = z.infer<typeof searchOptionsSchema>;
type GetPlaylistScoresOptions = z.infer<typeof getPlaylistScoresOptionsSchema>;
type GetNewsListingOptions = z.infer<typeof getNewsListingOptionsSchema>;
type GetNewsPostOptions = z.infer<typeof getNewsPostOptionsSchema>;
type GetRankingOptions = z.infer<typeof getRankingOptionsSchema>;
type GetSelfOptions = z.infer<typeof getSelfOptionsSchema>;
type GetUserKodosuOptions = z.infer<typeof getUserKudosuOptionsSchema>;
type GetUserScoresOptions = z.infer<typeof getUserScoresOptionsSchema>;
type GetUserRecentScoresOptions = z.infer<typeof getUserRecentScoresOptionsSchema>;
type GetUserBeatmapsOptions = z.infer<typeof getUserBeatmapsOptionsSchema>;
type GetUserRecentActivityOptions = z.infer<typeof getUserRecentActivityOptionsSchema>;
type GetUserOptions = z.infer<typeof getUserOptionsSchema>;
type GetUsersOptions = z.infer<typeof getUsersOptionsSchema>;

declare class Base {
    protected axios: AxiosInstance;
    constructor(accessToken: string);
    protected fetch<T>(endpoint: string, method: 'POST' | 'GET' | 'PATCH', options?: Options): Promise<T>;
}

/**
 * Class that wraps all user related endpoints
 */
declare class Users extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `me` endpoint (requires the `identify` scope)
     * @returns The user corresponding to the access token provided in the constructor of this class
     */
    getSelf(options?: GetSelfOptions): Promise<UserExtended & {
        is_restricted: boolean;
        statistics_rulesets: StatisticsRulesets;
    }>;
    /**
     * Makes a GET request to the `/users/{user}/kudosu` endpoint
     * @param user ID of the user to get kudosu from
     * @param options
     * @returns An array containing the specified user's kudosu history
     */
    getUserKudosu(user: number, options?: GetUserKodosuOptions): Promise<UserKudosuHistory[]>;
    /**
     * Makes a GET request to the `/users/{user}/recent_activity` endpoint
     * @param user ID of the user to get their recent activity from
     * @param options
     * @returns An array containing the specified user's recent activity (each event is a union, to discriminate, use the `type` key)
     */
    getUserRecentActivity(user: number, options?: GetUserRecentActivityOptions): Promise<UserEvent[]>;
    /**
     * Makes a GET request to the `/users/{user}/scores/{type}` endpoint
     * @param user ID of the user to get their scores
     * @param type Score type
     * @param options
     * @returns An array of the specified user's scores
     */
    getUserScores<T extends UserScoreType>(user: number, type: T, options?: T extends 'recent' ? GetUserRecentScoresOptions : GetUserScoresOptions): Promise<T extends 'best' ? UserBestScore[] : UserScore[]>;
    /**
     * Makes a GET request to the `/users/{user}/beatmapsets/{type}` endpoint
     * @param user ID of the user to get their beatmapsets
     * @param type Type of beatmapsets to return
     * @param options
     * @returns An array of a user's beatmapsets
     */
    getUserBeatmaps<T extends UserBeatmapsType>(user: number, type: T, options?: GetUserBeatmapsOptions): Promise<T extends 'most_played' ? BeatmapPlaycount[] : (Beatmapset & {
        beatmaps: (Beatmap & {
            checksum: string | null;
        })[];
    })[]>;
    /**
     * Makes a GET request to the `/users/{user}/{mode?}` endpoint
     * @param user ID or username of the user to get
     * @param options
     * @returns A user
     */
    getUser(user: number | string, options?: GetUserOptions): Promise<UserExtended>;
    /**
     * Makes a GET request to the `/users` endpoint
     * @returns An array of users
     */
    getUsers(options?: GetUsersOptions): Promise<(UserCompact & {
        country: Country;
        cover: Cover;
        groups: UserGroup[];
        statistics_rulesets: StatisticsRulesets;
    })[]>;
}

/**
 * Class that wraps all wiki related endpoints
 */
declare class Wiki extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/wiki/{locale}/{path}` endpoint
     * @param locale Two-letter language code of the wiki page
     * @param path Path to the wiki page
     * @returns The wiki page
     */
    getWikiPage(locale: string, path: string): Promise<WikiPage>;
}

/**
 * Class that wraps all comment related endpoints
 */
declare class Comments extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/comments` endpoint
     * @returns An object containing comments, users and other related data
     */
    getComments(options?: GetCommentsOptions): Promise<CommentBundle>;
    /**
     * Makes a GET request to the `/comments/{comment}` endpoint
     * @param comment ID of the comment to get related data from
     * @returns An object containing comments, users and other related data to the comment with the specified ID
     */
    getComment(comment: number): Promise<CommentBundle>;
}

/**
 * Class that wraps all multiplayer related endpoints
 */
declare class Multiplayer extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/rooms/{room}/playlist/{playlist}/scores` endpoint
     * @param room ID of the room corresponding to the playlist
     * @param playlist ID of the playlist to get scores from
     * @returns An object containing playlist scores and metadata
     */
    getPlaylistScores(room: number, playlist: number, options?: GetPlaylistScoresOptions): Promise<MultiplayerScores>;
}

/**
 * Class that wraps all ranking related endpoints
 */
declare class Ranking extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/rankings/{mode}/{type}` endpoint
     * @param mode Ranking gamemode
     * @param type Ranking type
     * @returns An object containing ranking data
     */
    getRanking(mode: GameMode, type: RankingType, options?: GetRankingOptions): Promise<Rankings>;
    /**
     * Makes a GET request to the `/spotights` endpoint
     * @returns An array of spotlights
     */
    getSpotlights(): Promise<Spotlight[]>;
}

/**
 * Class that wraps all news related endpoints
 */
declare class News extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/news` endpoint
     * @returns An object containing news posts and other additional data
     */
    getNewsListing(options?: GetNewsListingOptions): Promise<NewsListing>;
    /**
     * Makes a GET request to the `/news/{news}` endpoint
     * @param news ID or slug of the news post to get
     * @returns A news post
     */
    getNewsPost(news: string | number, options?: GetNewsPostOptions): Promise<NewsPost & {
        content: string;
        navigation: NewsNavigation;
    }>;
}

/**
 * Class that wraps all beatmap related endpoints
 */
declare class Beatmaps extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/beatmaps/lookup` endpoint
     * @returns A beatmap
     */
    lookupBeatmap(options?: LookupBeatmapOptions): Promise<(Beatmap & {
        beatmapset: Beatmapset & {
            ratings: number[];
        };
        checksum: string | null;
        failtimes: Fails;
        max_combo: number;
    }) | undefined>;
    /**
     * Makes a GET request to the `/beatmaps/{beatmap}/scores/users/{user}` endpoint
     * @param beatmap ID of the beatmap to get scores from
     * @param user ID of the user to get scores from
     * @returns A user score on a beatmap
     */
    getBeatmapUserScore(beatmap: number, user: number, options?: GetBeatmapScoresOptions): Promise<BeatmapUserScore>;
    /**
     * Makes a GET request to the `/beatmaps/{beatmap}/scores/users/{user}/all` endpoint
     * @param beatmap ID of the beatmap to get scores from
     * @param user ID of the user to get scores from
     * @returns An array of user scores on a beatmap
     */
    getBeatmapUserScores(beatmap: number, user: number, options?: GetBeatmapScoresOptions): Promise<Score[]>;
    /**
     * Makes a GET request to the `/beatmaps/{beatmap}/scores` endpoint
     * @param beatmap ID of the beatmap to get top scores from
     * @returns An array of user scores on a beatmap
     */
    getBeatmapTopScores(beatmap: number, options?: GetBeatmapScoresOptions): Promise<(Score & {
        user: UserCompact & {
            country: Country;
            cover: Cover;
        };
    })[]>;
    /**
     * Makes a GET request to the `/beatmaps` endpoint
     * @returns An array of beatmaps
     */
    getBeatmaps(options?: GetBeatmapsOptions): Promise<(Beatmap & {
        failtimes: Fails;
        max_combo: number;
        checksum: string | null;
        beatmapset: Beatmapset & {
            ratings: number[];
        };
    })[]>;
    /**
     * Makes a GET request to the `/beatmaps/{beatmap}` endpoint
     * @param beatmap ID of the beatmap to get
     * @returns A beatmap
     */
    getBeatmap(beatmap: number): Promise<Beatmap & {
        beatmapset: Beatmapset & {
            ratings: number[];
        };
        checksum: string | null;
        failtimes: Fails;
        max_combo: number;
    }>;
    /**
     * Makes a POST request to the `/beatmaps/{beatmap}/attributes` endpoint
     * @param beatmap ID of the beatmap to get its attributes
     * @param gamemode Gamemode attributes to get
     * @returns A beatmap's attributes
     */
    getBeatmapAttributes<T extends GameMode>(beatmap: number, gamemode: T, options?: GetBeatmapAttributesOptions): Promise<T extends 'osu' ? OsuBeatmapDifficultyAttributes : T extends 'taiko' ? TaikoBeatmapDifficultyAttributes : T extends 'fruits' ? FruitsBeatmapDifficultyAttributes : ManiaBeatmapDifficultyAttributes>;
}

/**
 * Class that wraps all changelog related endpoints
 */
declare class Changelog extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/changelog/{stream}/{build}` endpoint
     * @param stream Update stream name
     * @param build Build version
     * @returns A changelog build
     */
    getChangelogBuild(stream: ChangelogStream, build: string): Promise<Build & {
        changelog_entries: (ChangelogEntry & {
            github_user: GithubUser;
            message: string | null;
            message_html: string | null;
        })[];
        versions: BuildVersions;
    }>;
    /**
     * Makes a GET request to the `/changelog` endpoint
     * @returns An object containing a array of builds, update stream and search parameters used
     */
    getChangelogListing(options?: GetChangelogListingOptions): Promise<{
        builds: (Build & {
            changelog_entries: (ChangelogEntry & {
                github_user: GithubUser;
                message: string | null;
                message_html: string | null;
            })[];
        })[];
        search: {
            from: string | null;
            limit: 21;
            max_id: number | null;
            stream: string | null;
            to: string | null;
        };
        streams: (UpdateStream & {
            latest_build: Build;
            user_count: number;
        })[];
    }>;
    /**
     * Makes a GET request to the `/changelog/{changelog}` endpoint
     * @param changelog Build version, update stream name, or build ID
     * @returns A changelog build
     */
    lookupChangelogBuild(changelog: string | number, options?: LookupChangelogBuildOptions): Promise<(Build & {
        changelog_entries: (ChangelogEntry & {
            github_user: GithubUser;
            message: string | null;
            message_html: string | null;
        })[];
        versions: BuildVersions;
    }) | undefined>;
}

/**
 * Class that wraps all chat related endpoints
 */
declare class Chat extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a POST request to the `/chat/new` endpoint
     * @returns An object containing the message sent and the channel it was sent to
     */
    createPM(options: CreatePMOptions): Promise<{
        channel: Channel;
        message: ChatMessage;
    }>;
    /**
     * Makes a POST request to the `/chat/channels` endpoint
     * @param type Channel type to create or rejoin
     * @returns The created or rejoined channel
     */
    createChannel<T extends 'PM' | 'ANNOUNCE'>(type: T, options: T extends 'PM' ? CreatePMChannelOptions : CreateAnnounceChannelOptions): Promise<Channel>;
}

/**
 * Class that wraps all forum related endpoints
 */
declare class Forum extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a POST request to the `/forums/topics/{topic}/reply` endpoint
     * @param topic ID of the topic to reply to
     * @returns A forum post
     */
    replyToTopic(topic: number, options: ReplyToTopicOptions): Promise<ForumPost & {
        body: ForumPostBody;
    }>;
    /**
     * Makes a POST request to the `/forums/topics` endpoint
     * @returns A forum topic and the post attached to it
     */
    createTopic(options: CreateTopicOptions): Promise<{
        topic: ForumTopic;
        post: ForumPost & {
            body: ForumPostBody;
        };
    }>;
    /**
     * Makes a GET request to the `/forums/topics/{topic}` endpoint
     * @param topic ID of the topic to get its data and posts from
     * @returns An object containing the cursor string, posts and the topic itself
     */
    getTopic(topic: number, options?: GetTopicOptions): Promise<{
        cursor_string: Cursor;
        posts: (ForumPost & {
            body: ForumPostBody;
        })[];
        topic: ForumTopic;
    }>;
    /**
     * Makes a PATCH request to the `/forums/topics/{topic}` endpoint
     * @param topic ID of the topic to update
     * @returns A forum topic
     */
    updateTopic(topic: number, options?: UpdateTopicOptions): Promise<ForumTopic>;
    /**
     * Makes a PATCH request to the `/forums/posts/{post}` endpoint
     * @param post ID of the post to update
     * @returns A forum post
     */
    updatePost(post: number, options: UpdatePostOptions): Promise<ForumPost & {
        body: ForumPostBody;
    }>;
}

/**
 * Class that wraps all beatmapset discussion related endpoints
 */
declare class BeatmapsetDiscussions extends Base {
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/beatmapsets/discussions/posts` endpoint
     * @returns An object containing a cursor and arrays of beatmapsets, users, discussions and posts
     */
    getDiscussionPosts(options?: GetDiscussionPostsOptions): Promise<{
        beatmapsets: BeatmapsetCompact[];
        cursor_string: Cursor;
        discussions: BeatmapsetDiscussion[];
        posts: DiscussionPost[];
        users: UserCompact[];
    }>;
    /**
     * Makes a GET request to the `/beatmapsets/discussions/votes` endpoint
     * @returns An object containing a cursor and arrays of discussions, users and votes
     */
    getDiscussionVotes(options?: GetDiscussionVotesOptions): Promise<{
        cursor_string: Cursor;
        discussions: BeatmapsetDiscussion[];
        users: UserCompact[];
        votes: DiscussionVote[];
    }>;
    /**
     * Makes a GET request to the `/beatmapsets/discussions` endpoint
     * @returns An object containing a cursor and arrays of beatmaps, discussions and users
     */
    getDiscussions(options?: GetDiscussionsOptions): Promise<{
        cursor_string: Cursor;
        users: UserCompact[];
        discussions: BeatmapsetDiscussion[];
        included_discussions: BeatmapsetDiscussion[];
        beatmapsets: BeatmapsetCompact[];
        beatmaps: (Beatmap & {
            checksum: string | null;
        })[];
        reviews_config: {
            max_blocks: number;
        };
    }>;
}

/**
 * Class that wraps all endpoints of the current API (API v2)
 */
declare class Client extends Base {
    beatmaps: Beatmaps;
    beatmapsetDiscussions: BeatmapsetDiscussions;
    changelog: Changelog;
    chat: Chat;
    comments: Comments;
    forum: Forum;
    multiplayer: Multiplayer;
    news: News;
    ranking: Ranking;
    users: Users;
    wiki: Wiki;
    /**
     * @param accessToken OAuth access token
     */
    constructor(accessToken: string);
    /**
     * Makes a GET request to the `/search` endpoint
     * @returns Users and wiki pages as results
     */
    search(options?: SearchOptions): Promise<SearchResults>;
    /**
     * Make a GET request to an undocumented endpoint
     * @param endpoint The endpoint to make a request to
     */
    getUndocumented<T>(endpoint: string, options?: Omit<Options, 'body'>): Promise<T>;
}

declare const getBeatmapsParamsSchema: z.ZodObject<{
    /** Beatmaps ranked or loved since this date (in UTC) */
    since: z.ZodOptional<z.ZodDate>;
    /** Beatmaps with a specific beatmapset ID */
    s: z.ZodOptional<z.ZodNumber>;
    /** Beatmap with a specific beatmap ID */
    b: z.ZodOptional<z.ZodNumber>;
    /** Beatmaps created by user with a specific user ID or username */
    u: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
    /** Specify if `u` is a user ID (`id`) or a username (`string`) */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"string">, z.ZodLiteral<"id">]>>;
    /** Beatmaps from a specific gamemode */
    m: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    /** Include converted beatmaps? */
    a: z.ZodOptional<z.ZodBoolean>;
    /** Beatmap with a specific hash */
    h: z.ZodOptional<z.ZodString>;
    /** Limit amount of beatmaps to return (500 max.) */
    limit: z.ZodOptional<z.ZodNumber>;
    /** Mods to apply */
    mods: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"NF">, z.ZodLiteral<"EZ">, z.ZodLiteral<"TD">, z.ZodLiteral<"HD">, z.ZodLiteral<"HR">, z.ZodLiteral<"SD">, z.ZodLiteral<"DT">, z.ZodLiteral<"RX">, z.ZodLiteral<"HT">, z.ZodLiteral<"NC">, z.ZodLiteral<"FL">, z.ZodLiteral<"AT">, z.ZodLiteral<"SO">, z.ZodLiteral<"AP">, z.ZodLiteral<"PF">, z.ZodLiteral<"FI">, z.ZodLiteral<"RN">, z.ZodLiteral<"CN">, z.ZodLiteral<"TR">, z.ZodLiteral<"KC">, z.ZodLiteral<"SV2">, z.ZodLiteral<"MR">, z.ZodLiteral<"K1">, z.ZodLiteral<"K2">, z.ZodLiteral<"K3">, z.ZodLiteral<"K4">, z.ZodLiteral<"K5">, z.ZodLiteral<"K6">, z.ZodLiteral<"K7">, z.ZodLiteral<"K8">, z.ZodLiteral<"K9">]>, "many">>;
}, "strip", z.ZodTypeAny, {
    type?: "string" | "id" | undefined;
    limit?: number | undefined;
    mods?: ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    since?: Date | undefined;
    s?: number | undefined;
    b?: number | undefined;
    u?: string | number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    a?: boolean | undefined;
    h?: string | undefined;
}, {
    type?: "string" | "id" | undefined;
    limit?: number | undefined;
    mods?: ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    since?: Date | undefined;
    s?: number | undefined;
    b?: number | undefined;
    u?: string | number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    a?: boolean | undefined;
    h?: string | undefined;
}>;
declare const getUserParamsSchema: z.ZodObject<{
    /** User with a specific user ID or username */
    u: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
    /** User gamemode profile  */
    m: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    /** Specify if `u` is a user ID (`id`) or a username (`string`) */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"string">, z.ZodLiteral<"id">]>>;
    /** Max. number of days between now and the last event's date (range: 1-31) */
    event_days: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    type?: "string" | "id" | undefined;
    u?: string | number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    event_days?: number | undefined;
}, {
    type?: "string" | "id" | undefined;
    u?: string | number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    event_days?: number | undefined;
}>;
declare const getBeatmapScoresParamsSchema: z.ZodObject<{
    /** Scores from a beatmap with a specific beatmap ID */
    b: z.ZodNumber;
    /** Scores from a user with a specific user ID or username */
    u: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
    /** Scores from a specific gamemode  */
    m: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    /** Limit amount of scores to return (100 max.) */
    limit: z.ZodOptional<z.ZodNumber>;
    /** Specify if `u` is a user ID (`id`) or a username (`string`) */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"string">, z.ZodLiteral<"id">]>>;
}, "strip", z.ZodTypeAny, {
    type?: "string" | "id" | undefined;
    limit?: number | undefined;
    u?: string | number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    b: number;
}, {
    type?: "string" | "id" | undefined;
    limit?: number | undefined;
    u?: string | number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    b: number;
}>;
declare const getUserScoresParamsSchema: z.ZodObject<{
    /** Scores from a user with a specific user ID or username */
    u: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    /** Scores from a specific gamemode  */
    m: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    /** Limit amount of scores to return (100 max.) */
    limit: z.ZodOptional<z.ZodNumber>;
    /** Specify if `u` is a user ID (`id`) or a username (`string`) */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"string">, z.ZodLiteral<"id">]>>;
}, "strip", z.ZodTypeAny, {
    type?: "string" | "id" | undefined;
    limit?: number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    u: string | number;
}, {
    type?: "string" | "id" | undefined;
    limit?: number | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    u: string | number;
}>;
declare const getMultiplayerLobbyParamsSchema: z.ZodObject<{
    /** Match with a specific match ID */
    mp: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    mp: number;
}, {
    mp: number;
}>;
declare const getReplayByScoreIdParamsSchema: z.ZodObject<{
    /** Replay from a score with a specific score ID */
    s: z.ZodNumber;
    /** Replay gamemode */
    m: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    /** Replay with a specific list of mods */
    mods: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"NF">, z.ZodLiteral<"EZ">, z.ZodLiteral<"TD">, z.ZodLiteral<"HD">, z.ZodLiteral<"HR">, z.ZodLiteral<"SD">, z.ZodLiteral<"DT">, z.ZodLiteral<"RX">, z.ZodLiteral<"HT">, z.ZodLiteral<"NC">, z.ZodLiteral<"FL">, z.ZodLiteral<"AT">, z.ZodLiteral<"SO">, z.ZodLiteral<"AP">, z.ZodLiteral<"PF">, z.ZodLiteral<"FI">, z.ZodLiteral<"RN">, z.ZodLiteral<"CN">, z.ZodLiteral<"TR">, z.ZodLiteral<"KC">, z.ZodLiteral<"SV2">, z.ZodLiteral<"MR">, z.ZodLiteral<"K1">, z.ZodLiteral<"K2">, z.ZodLiteral<"K3">, z.ZodLiteral<"K4">, z.ZodLiteral<"K5">, z.ZodLiteral<"K6">, z.ZodLiteral<"K7">, z.ZodLiteral<"K8">, z.ZodLiteral<"K9">]>, "many">>;
}, "strip", z.ZodTypeAny, {
    mods?: ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    s: number;
}, {
    mods?: ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    s: number;
}>;
declare const getReplayByBeatmapAndUserIdParamsSchema: z.ZodObject<{
    /** Replay from a beatmap with a specific beatmap ID */
    b: z.ZodNumber;
    /** Replay from a user with a specific user ID or username */
    u: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    /** Specify if `u` is a user ID (`id`) or a username (`string`) */
    type: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"string">, z.ZodLiteral<"id">]>>;
    /** Replay gamemode */
    m: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"fruits">, z.ZodLiteral<"mania">, z.ZodLiteral<"osu">, z.ZodLiteral<"taiko">]>>;
    /** Replay with a specific list of mods */
    mods: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodLiteral<"NF">, z.ZodLiteral<"EZ">, z.ZodLiteral<"TD">, z.ZodLiteral<"HD">, z.ZodLiteral<"HR">, z.ZodLiteral<"SD">, z.ZodLiteral<"DT">, z.ZodLiteral<"RX">, z.ZodLiteral<"HT">, z.ZodLiteral<"NC">, z.ZodLiteral<"FL">, z.ZodLiteral<"AT">, z.ZodLiteral<"SO">, z.ZodLiteral<"AP">, z.ZodLiteral<"PF">, z.ZodLiteral<"FI">, z.ZodLiteral<"RN">, z.ZodLiteral<"CN">, z.ZodLiteral<"TR">, z.ZodLiteral<"KC">, z.ZodLiteral<"SV2">, z.ZodLiteral<"MR">, z.ZodLiteral<"K1">, z.ZodLiteral<"K2">, z.ZodLiteral<"K3">, z.ZodLiteral<"K4">, z.ZodLiteral<"K5">, z.ZodLiteral<"K6">, z.ZodLiteral<"K7">, z.ZodLiteral<"K8">, z.ZodLiteral<"K9">]>, "many">>;
}, "strip", z.ZodTypeAny, {
    type?: "string" | "id" | undefined;
    mods?: ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    b: number;
    u: string | number;
}, {
    type?: "string" | "id" | undefined;
    mods?: ("NF" | "EZ" | "TD" | "HD" | "HR" | "SD" | "DT" | "RX" | "HT" | "NC" | "FL" | "AT" | "SO" | "AP" | "PF" | "FI" | "RN" | "CN" | "TR" | "KC" | "SV2" | "MR" | "K1" | "K2" | "K3" | "K4" | "K5" | "K6" | "K7" | "K8" | "K9")[] | undefined;
    m?: "fruits" | "mania" | "osu" | "taiko" | undefined;
    b: number;
    u: string | number;
}>;

/**
 * Timestamp string in ODBC canonical format
 */
type ODBCTimestamp = string;
type GetBeatmapsParams = z.infer<typeof getBeatmapsParamsSchema>;
type GetUserParams = z.infer<typeof getUserParamsSchema>;
type GetBeatmapScoresParams = z.infer<typeof getBeatmapScoresParamsSchema>;
type GetUserScoresParams = z.infer<typeof getUserScoresParamsSchema>;
type GetMultiplayerLobbyParams = z.infer<typeof getMultiplayerLobbyParamsSchema>;
type GetReplayByScoreIdParams = z.infer<typeof getReplayByScoreIdParamsSchema>;
type GetReplayByBeatmapAndUserIdParams = z.infer<typeof getReplayByBeatmapAndUserIdParamsSchema>;
type Genre = keyof typeof GenresEnum;
type Language = keyof typeof LanguagesEnum;
type ScoringType = keyof typeof ScoringTypeEnum;
type TeamType = keyof typeof TeamTypeEnum;
type TeamColor = keyof typeof TeamColorEnum;
interface LegacyBeatmap {
    approved: RankStatus;
    submit_date: ODBCTimestamp;
    approved_date: ODBCTimestamp;
    last_update: ODBCTimestamp;
    artist: string;
    beatmap_id: number;
    beatmapset_id: number;
    bpm: number;
    creator: string;
    creator_id: number;
    difficultyrating: number;
    diff_aim: number;
    diff_speed: number;
    diff_size: number;
    diff_overall: number;
    diff_approach: number;
    diff_drain: number;
    hit_length: number;
    source: string;
    genre: Genre;
    language: Language;
    title: string;
    total_length: number;
    version: string;
    file_md5: string;
    mode: GameMode;
    tags: string[];
    favourite_count: number;
    rating: number;
    playcount: number;
    passcount: number;
    count_normal: number;
    count_slider: number;
    count_spinner: number;
    max_combo: number;
    storyboard: boolean;
    video: boolean;
    download_available: boolean;
    audio_available: boolean;
}
interface LegacyUser {
    user_id: number;
    username: string;
    join_date: ODBCTimestamp;
    count300: number;
    count100: number;
    count50: number;
    playcount: number;
    ranked_score: number;
    total_score: number;
    pp_rank: number;
    level: number;
    pp_raw: number;
    accuracy: number;
    count_rank_ss: number;
    count_rank_ssh: number;
    count_rank_s: number;
    count_rank_sh: number;
    count_rank_a: number;
    country: string;
    total_seconds_played: number;
    pp_country_rank: number;
    events: LegacyEvent[];
}
interface LegacyEvent {
    display_html: string;
    beatmap_id: number;
    beatmapset_id: number;
    date: ODBCTimestamp;
    epicfactor: number;
}
interface BaseScore {
    score: number;
    count300: number;
    count100: number;
    count50: number;
    countmiss: number;
    maxcombo: number;
    countkatu: number;
    countgeki: number;
    perfect: boolean;
    enabled_mods: Mod[];
}
interface LegacyBeatmapScore extends BaseScore {
    score_id: number;
    username: string;
    user_id: number;
    date: ODBCTimestamp;
    rank: Rank;
    pp: number;
    replay_available: boolean;
}
interface LegacyUserRecentScore extends BaseScore {
    beatmap_id: number;
    user_id: number;
    date: ODBCTimestamp;
    rank: Rank;
}
interface LegacyUserBestScore extends LegacyUserRecentScore {
    score_id: number;
    pp: number;
    replay_available: boolean;
}
interface LegacyMultiplayerLobby {
    match: LegacyMatch;
    games: LegacyGame[];
}
interface LegacyMatch {
    match_id: number;
    name: string;
    start_time: ODBCTimestamp;
    end_time: ODBCTimestamp | null;
}
interface LegacyGame {
    game_id: number;
    start_time: ODBCTimestamp;
    end_time: ODBCTimestamp | null;
    beatmap_id: number;
    play_mode: GameMode;
    scoring_type: ScoringType;
    team_type: TeamType;
    mods: Mod[];
    scores: LegacyMatchScore[];
}
interface LegacyMatchScore extends Omit<BaseScore, 'enabled_mods'> {
    slot: number;
    team: TeamColor | null;
    user_id: number;
    pass: boolean;
    enabled_mods: Mod[];
}

/**
 * Class that wraps all endpoints of the legacy API (API v1)
 */
declare class LegacyClient {
    private apiKey;
    /**
     * @param apiKey API key
     */
    constructor(apiKey: string);
    private fetch;
    /**
     * Makes a GET request to the `get_beatmaps` endpoint
     * @returns An array of beatmaps
     */
    getBeatmaps(params: GetBeatmapsParams): Promise<LegacyBeatmap[]>;
    /**
     * Makes a GET request to the `get_user` endpoint
     * @returns A user if it exists, otherwise null
     */
    getUser(params: GetUserParams): Promise<LegacyUser | null>;
    /**
     * Makes a GET request to the `get_scores` endpoint
     * @returns An array of scores on a beatmap
     */
    getBeatmapScores(params: GetBeatmapScoresParams): Promise<LegacyBeatmapScore[]>;
    private getUserScores;
    /**
     * Makes a GET request to the `get_user_best` endpoint
     * @returns An array of a user's top scores
     */
    getUserBestScores(params: GetUserScoresParams): Promise<LegacyUserBestScore[]>;
    /**
     * Makes a GET request to the `get_user_recent` endpoint
     * @returns An array of a user's most recent scores in 24 hours
     */
    getUserRecentScores(params: GetUserScoresParams): Promise<LegacyUserRecentScore[]>;
    /**
     * Makes a GET request to the `get_match` endpoint
     * @returns An object containing the match's information, games and each games' scores if the multiplayer lobby exists, otherwise null
     */
    getMultiplayerLobby(params: GetMultiplayerLobbyParams): Promise<LegacyMultiplayerLobby | null>;
    /**
     * Makes a GET request to the `get_replay`
     * @param by Get replay by `score id` or `user & beatmap id`
     * @returns A string containing the Base64 encoded replay if the replay exists, otherwise null
     */
    getReplay<T extends 'score id' | 'user & beatmap id'>(by: T, params: T extends 'score id' ? GetReplayByScoreIdParams : GetReplayByBeatmapAndUserIdParams): Promise<string | null>;
}

/**
 * URL builder
 */
declare const buildUrl: {
    /**
     * Create a custom URL using the ppy.sh domain as a base
     * @param path Path to set after `https://{subdomain}.ppy.sh/`
     * @param subdomain Specify a subdomain to point to, defaults to `osu`
     */
    custom: typeof createUrl;
    beatmapsetCover: (beatmapsetId: number) => string;
    beatmapsetThumbnail: (beatmapsetId: number) => string;
    beatmap: (beatmapId: number) => string;
    beatmapset: (beatmapsetId: number) => string;
    userAvatar: (userId: number) => string;
    user: (userId: number) => string;
    score: (gamemode: GameMode, scoreId: number) => string;
    forum: (forumId: number) => string;
    forumTopic: (topicId: number) => string;
    room: (roomId: number) => string;
    match: (matchId: number) => string;
    /**
     * @param clientId OAuth client ID
     * @param redirectUri OAuth redirect URI
     * @param scopes An array of OAuth scopes
     * @param state Data that will be returned when a temporary code is issued. It can be used to provide a token for protecting against cross-site request forgery attacks
     */
    authRequest: (clientId: number, redirectUri: string, scopes?: Scope[], state?: string) => string;
};
declare function createUrl(path: string, subdomain?: string): string;
/**
 * Score accuracy calculator
 */
declare const calcAccuracy: {
    /**
     * Calculate accuracy for osu! standard
     * @param c300 300s
     * @param c100 100s
     * @param c50 50s
     * @param misses Misses
     */
    osu: (c300: number, c100: number, c50: number, misses: number) => number;
    /**
     * Calculate accuracy for osu! taiko
     * @param geki Greats
     * @param katu Goods
     * @param misses Misses
     */
    taiko: (geki: number, katu: number, misses: number) => number;
    /**
     * Calculate accuracy for osu! catch
     * @param c300 Caught fruits
     * @param c100 Caught drops
     * @param c50 Caught droplets
     * @param katu Drops
     * @param misses Droplets
     */
    fruits: (c300: number, c100: number, c50: number, katu: number, misses: number) => number;
    /**
     * Calculate accuracy for osu! mania
     * @param geki Maxes
     * @param c300 300s
     * @param katu 200s
     * @param c100 100s
     * @param c50 50s
     * @param misses Misses
     * @param scoreV2 Apply score V2 formula?
     */
    mania: (geki: number, c300: number, katu: number, c100: number, c50: number, misses: number, scoreV2?: boolean) => number;
};
/**
 * Beatmap stat calculator based on mods
 */
declare const calcModStat: {
    hr: {
        cs: (n: number) => number;
        od: typeof hrStat;
        ar: typeof hrStat;
        hp: typeof hrStat;
    };
    dt: {
        od: (n: number) => number;
        bpm: (n: number) => number;
        ar: (n: number) => number;
        length: (n: number) => number;
    };
    ez: {
        cs: typeof ezStat;
        od: typeof ezStat;
        ar: typeof ezStat;
        hp: typeof ezStat;
    };
    ht: {
        od: (n: number) => number;
        bpm: (n: number) => number;
        ar: (n: number) => number;
        length: (n: number) => number;
    };
};
declare function hrStat(n: number): number;
declare function ezStat(n: number): number;

export { AchievementGrouping, Auth, AuthCodeGrant, Beatmap, BeatmapCompact, BeatmapPlaycount, BeatmapUserScore, Beatmaps, Beatmapset, BeatmapsetAvailability, BeatmapsetCompact, BeatmapsetDiscussion, BeatmapsetDiscussions, BeatmapsetHype, Build, BuildVersions, Changelog, ChangelogEntry, ChangelogStream, Channel, ChannelType, Chat, ChatMessage, ChatMessageType, Client, Comment, CommentBundle, CommentSort, CommentableMetadata, CommentableType, Comments, Country, Cover, Covers, CreateAnnounceChannelOptions, CreatePMChannelOptions, CreatePMOptions, CreateTopicOptions, Cursor, DiscussionMessageType, DiscussionPost, DiscussionVote, EventAchievement, EventBeatmap, EventBeatmapsetApprovedType, EventUser, Fails, Forum, ForumPoll, ForumPollOptions, ForumPost, ForumPostBody, ForumTopic, ForumTopicType, FruitsBeatmapDifficultyAttributes, GameMode, Genre, GenresEnum, GetBeatmapAttributesOptions, GetBeatmapOptions, GetBeatmapScoresOptions, GetBeatmapScoresParams, GetBeatmapsOptions, GetBeatmapsParams, GetChangelogListingOptions, GetCommentsOptions, GetDiscussionPostsOptions, GetDiscussionVotesOptions, GetDiscussionsOptions, GetMultiplayerLobbyParams, GetNewsListingOptions, GetNewsPostOptions, GetPlaylistScoresOptions, GetRankingOptions, GetReplayByBeatmapAndUserIdParams, GetReplayByScoreIdParams, GetSelfOptions, GetTopicOptions, GetUserBeatmapsOptions, GetUserKodosuOptions, GetUserOptions, GetUserParams, GetUserRecentActivityOptions, GetUserRecentScoresOptions, GetUserScoresOptions, GetUserScoresParams, GetUsersOptions, GithubUser, Giver, GradeCounts, Group, GuestToken, ISOTimestamp, KudosuAction, Language, LanguagesEnum, LegacyBeatmap, LegacyBeatmapScore, LegacyClient, LegacyEvent, LegacyGame, LegacyMatch, LegacyMatchScore, LegacyMultiplayerLobby, LegacyUser, LegacyUserBestScore, LegacyUserRecentScore, LookupBeatmapOptions, LookupChangelogBuildOptions, ManiaBeatmapDifficultyAttributes, Mod, ModesEnum, ModsEnum, MonthlyPlaycount, Multiplayer, MultiplayerScore, MultiplayerScoreMod, MultiplayerScoreStatistics, MultiplayerScores, MultiplayerScoresParams, MultiplayerScoresSort, News, NewsListing, NewsNavigation, NewsPost, NewsSearch, NewsSidebar, ODBCTimestamp, Options, OsuBeatmapDifficultyAttributes, Page, Playstyle, Post, ProfilePageSection, Rank, RankHighest, RankHistory, RankStatus, Ranking, RankingType, Rankings, ReplyToTopicOptions, Scope, Score, ScoreStatistics, ScoringType, ScoringTypeEnum, SearchOptions, SearchResult, SearchResults, Spotlight, SpotlightType, StatisticsRulesets, StatusEnum, TaikoBeatmapDifficultyAttributes, TeamColor, TeamColorEnum, TeamType, TeamTypeEnum, Token, UpdatePostOptions, UpdateStream, UpdateTopicOptions, User, UserAccountHistory, UserAccountHistoryType, UserAchievement, UserActiveTournamentBanner, UserBadge, UserBeatmapsType, UserBestScore, UserCompact, UserEvent, UserEventAchievement, UserEventBeatmapPlaycount, UserEventBeatmapsetApprove, UserEventBeatmapsetDelete, UserEventBeatmapsetUpdate, UserEventRankAchieved, UserEventRankLost, UserEventType, UserEventUserUpdate, UserEventUsernameUpdate, UserExtended, UserGroup, UserKudosu, UserKudosuHistory, UserLevel, UserScore, UserScoreType, UserStatistics, Users, Weight, Wiki, WikiPage, buildUrl, calcAccuracy, calcModStat };
