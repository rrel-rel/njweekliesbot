"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Auth: () => Auth,
  AuthCodeGrant: () => AuthCodeGrant,
  Beatmaps: () => Beatmaps,
  BeatmapsetDiscussions: () => BeatmapsetDiscussions,
  Changelog: () => Changelog,
  Chat: () => Chat,
  Client: () => Client,
  Comments: () => Comments,
  Forum: () => Forum,
  GenresEnum: () => GenresEnum,
  LanguagesEnum: () => LanguagesEnum,
  LegacyClient: () => LegacyClient,
  ModesEnum: () => ModesEnum,
  ModsEnum: () => ModsEnum,
  Multiplayer: () => Multiplayer,
  News: () => News,
  Ranking: () => Ranking,
  ScoringTypeEnum: () => ScoringTypeEnum,
  StatusEnum: () => StatusEnum,
  TeamColorEnum: () => TeamColorEnum,
  TeamTypeEnum: () => TeamTypeEnum,
  Users: () => Users,
  Wiki: () => Wiki,
  buildUrl: () => buildUrl,
  calcAccuracy: () => calcAccuracy,
  calcModStat: () => calcModStat
});
module.exports = __toCommonJS(src_exports);

// src/classes/auth/Base.ts
var Base = class {
  constructor(clientId, clientSecret, redirectUri) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectUri = redirectUri;
    this.oauthUrl = "https://osu.ppy.sh/oauth/";
    this.headers = {
      headers: {
        "Accept-Encoding": "*"
      }
    };
  }
};

// src/classes/auth/Auth.ts
var import_axios2 = __toESM(require("axios"), 1);

// src/classes/auth/AuthCodeGrant.ts
var import_axios = __toESM(require("axios"), 1);
var AuthCodeGrant = class extends Base {
  /**
   * @param clientId OAuth client ID
   * @param clientSecret OAuth client secret
   * @param redirectUri OAuth redirect URI
   * @param scopes An array of OAuth scopes
   */
  constructor(clientId, clientSecret, redirectUri, scopes) {
    super(clientId, clientSecret, redirectUri);
    this.scopes = scopes;
  }
  /**
   * Gets a token
   * @param code The string received after a user authorizes the app
   * @returns An API token
   */
  requestToken(code) {
    return __async(this, null, function* () {
      let resp = yield import_axios.default.post(
        `${this.oauthUrl}token`,
        {
          client_id: this.clientId,
          client_secret: this.clientSecret,
          code,
          grant_type: "authorization_code",
          redirect_uri: this.redirectUri
        },
        this.headers
      );
      let token = resp.data;
      return token;
    });
  }
  /**
   * Refreshes a token
   * @param refreshToken The token used to refresh
   * @returns An API token
   */
  refreshToken(refreshToken) {
    return __async(this, null, function* () {
      let resp = yield import_axios.default.post(
        `${this.oauthUrl}token`,
        {
          client_id: this.clientId,
          client_secret: this.clientSecret,
          refresh_token: refreshToken,
          grant_type: "refresh_token",
          scope: this.scopes
        },
        this.headers
      );
      let token = resp.data;
      return token;
    });
  }
};

// src/classes/auth/Auth.ts
var Auth = class extends Base {
  /**
   * @param clientId OAuth client ID
   * @param clientSecret OAuth client secret
   * @param redirectUri OAuth redirect URI
   */
  constructor(clientId, clientSecret, redirectUri) {
    super(clientId, clientSecret, redirectUri);
  }
  /**
   * @param scopes An array of scopes
   */
  authorizationCodeGrant(scopes = ["identify"]) {
    return new AuthCodeGrant(this.clientId, this.clientSecret, this.redirectUri, scopes);
  }
  /**
   * Gets a token
   * @returns An API token (with guest permissions)
   */
  clientCredentialsGrant() {
    return __async(this, null, function* () {
      let resp = yield import_axios2.default.post(
        `${this.oauthUrl}token`,
        {
          client_id: this.clientId,
          client_secret: this.clientSecret,
          grant_type: "client_credentials",
          scope: "public"
        },
        this.headers
      );
      let token = resp.data;
      return token;
    });
  }
  /**
   * Revokes a token
   * @param accessToken Access toke to revoke
   */
  revokeToken(accessToken) {
    return __async(this, null, function* () {
      yield import_axios2.default.delete("https://osu.ppy.sh/api/v2/oauth/tokens/current", {
        headers: __spreadProps(__spreadValues({}, this.headers.headers), {
          Authorization: `Bearer ${accessToken}`
        })
      });
    });
  }
};

// src/schemas/index.ts
var import_zod = require("zod");
var baseQuery = {
  /** Limit number of results */
  limit: import_zod.z.number(),
  /** Pagination offset */
  offset: import_zod.z.number()
};
var gameModeSchema = import_zod.z.union([
  import_zod.z.literal("fruits"),
  import_zod.z.literal("mania"),
  import_zod.z.literal("osu"),
  import_zod.z.literal("taiko")
]);
var modsSchema = import_zod.z.array(
  import_zod.z.union([
    import_zod.z.literal("NF"),
    import_zod.z.literal("EZ"),
    import_zod.z.literal("TD"),
    import_zod.z.literal("HD"),
    import_zod.z.literal("HR"),
    import_zod.z.literal("SD"),
    import_zod.z.literal("DT"),
    import_zod.z.literal("RX"),
    import_zod.z.literal("HT"),
    import_zod.z.literal("NC"),
    import_zod.z.literal("FL"),
    import_zod.z.literal("AT"),
    import_zod.z.literal("SO"),
    import_zod.z.literal("AP"),
    import_zod.z.literal("PF"),
    import_zod.z.literal("FI"),
    import_zod.z.literal("RN"),
    import_zod.z.literal("CN"),
    import_zod.z.literal("TR"),
    import_zod.z.literal("KC"),
    import_zod.z.literal("SV2"),
    import_zod.z.literal("MR"),
    import_zod.z.literal("K1"),
    import_zod.z.literal("K2"),
    import_zod.z.literal("K3"),
    import_zod.z.literal("K4"),
    import_zod.z.literal("K5"),
    import_zod.z.literal("K6"),
    import_zod.z.literal("K7"),
    import_zod.z.literal("K8"),
    import_zod.z.literal("K9")
  ])
);
var searchOptionsSchema = import_zod.z.object({
  query: import_zod.z.object({
    /** Search only users, only wiki pages or both */
    mode: import_zod.z.union([import_zod.z.literal("all"), import_zod.z.literal("user"), import_zod.z.literal("wiki_page")]),
    /** Query string to search */
    query: import_zod.z.string(),
    /** Page number */
    page: import_zod.z.number()
  })
}).deepPartial();

// src/classes/Base.ts
var import_axios3 = __toESM(require("axios"), 1);
var import_zod2 = require("zod");

// src/utils/enums.ts
var ModesEnum = /* @__PURE__ */ ((ModesEnum2) => {
  ModesEnum2[ModesEnum2["osu"] = 0] = "osu";
  ModesEnum2[ModesEnum2["taiko"] = 1] = "taiko";
  ModesEnum2[ModesEnum2["fruits"] = 2] = "fruits";
  ModesEnum2[ModesEnum2["mania"] = 3] = "mania";
  return ModesEnum2;
})(ModesEnum || {});
var StatusEnum = /* @__PURE__ */ ((StatusEnum2) => {
  StatusEnum2[StatusEnum2["graveyard"] = -2] = "graveyard";
  StatusEnum2[StatusEnum2["wip"] = -1] = "wip";
  StatusEnum2[StatusEnum2["pending"] = 0] = "pending";
  StatusEnum2[StatusEnum2["ranked"] = 1] = "ranked";
  StatusEnum2[StatusEnum2["approved"] = 2] = "approved";
  StatusEnum2[StatusEnum2["qualified"] = 3] = "qualified";
  StatusEnum2[StatusEnum2["loved"] = 4] = "loved";
  return StatusEnum2;
})(StatusEnum || {});
var GenresEnum = /* @__PURE__ */ ((GenresEnum2) => {
  GenresEnum2[GenresEnum2["Any"] = 0] = "Any";
  GenresEnum2[GenresEnum2["Unspecified"] = 1] = "Unspecified";
  GenresEnum2[GenresEnum2["Video Game"] = 2] = "Video Game";
  GenresEnum2[GenresEnum2["Anime"] = 3] = "Anime";
  GenresEnum2[GenresEnum2["Rock"] = 4] = "Rock";
  GenresEnum2[GenresEnum2["Pop"] = 5] = "Pop";
  GenresEnum2[GenresEnum2["Other"] = 6] = "Other";
  GenresEnum2[GenresEnum2["Novelty"] = 7] = "Novelty";
  GenresEnum2[GenresEnum2["Hip Hop"] = 9] = "Hip Hop";
  GenresEnum2[GenresEnum2["Electronic"] = 10] = "Electronic";
  GenresEnum2[GenresEnum2["Metal"] = 11] = "Metal";
  GenresEnum2[GenresEnum2["Classical"] = 12] = "Classical";
  GenresEnum2[GenresEnum2["Folk"] = 13] = "Folk";
  GenresEnum2[GenresEnum2["Jazz"] = 14] = "Jazz";
  return GenresEnum2;
})(GenresEnum || {});
var LanguagesEnum = /* @__PURE__ */ ((LanguagesEnum2) => {
  LanguagesEnum2[LanguagesEnum2["Any"] = 0] = "Any";
  LanguagesEnum2[LanguagesEnum2["Unspecified"] = 1] = "Unspecified";
  LanguagesEnum2[LanguagesEnum2["English"] = 2] = "English";
  LanguagesEnum2[LanguagesEnum2["Japanese"] = 3] = "Japanese";
  LanguagesEnum2[LanguagesEnum2["Chinese"] = 4] = "Chinese";
  LanguagesEnum2[LanguagesEnum2["Instrumental"] = 5] = "Instrumental";
  LanguagesEnum2[LanguagesEnum2["Korean"] = 6] = "Korean";
  LanguagesEnum2[LanguagesEnum2["French"] = 7] = "French";
  LanguagesEnum2[LanguagesEnum2["German"] = 8] = "German";
  LanguagesEnum2[LanguagesEnum2["Swedish"] = 9] = "Swedish";
  LanguagesEnum2[LanguagesEnum2["Spanish"] = 10] = "Spanish";
  LanguagesEnum2[LanguagesEnum2["Italian"] = 11] = "Italian";
  LanguagesEnum2[LanguagesEnum2["Russian"] = 12] = "Russian";
  LanguagesEnum2[LanguagesEnum2["Polish"] = 13] = "Polish";
  LanguagesEnum2[LanguagesEnum2["Other"] = 14] = "Other";
  return LanguagesEnum2;
})(LanguagesEnum || {});
var ModsEnum = /* @__PURE__ */ ((ModsEnum2) => {
  ModsEnum2[ModsEnum2["NF"] = 1] = "NF";
  ModsEnum2[ModsEnum2["EZ"] = 2] = "EZ";
  ModsEnum2[ModsEnum2["TD"] = 4] = "TD";
  ModsEnum2[ModsEnum2["HD"] = 8] = "HD";
  ModsEnum2[ModsEnum2["HR"] = 16] = "HR";
  ModsEnum2[ModsEnum2["SD"] = 32] = "SD";
  ModsEnum2[ModsEnum2["DT"] = 64] = "DT";
  ModsEnum2[ModsEnum2["RX"] = 128] = "RX";
  ModsEnum2[ModsEnum2["HT"] = 256] = "HT";
  ModsEnum2[ModsEnum2["NC"] = 512] = "NC";
  ModsEnum2[ModsEnum2["FL"] = 1024] = "FL";
  ModsEnum2[ModsEnum2["AT"] = 2048] = "AT";
  ModsEnum2[ModsEnum2["SO"] = 4096] = "SO";
  ModsEnum2[ModsEnum2["AP"] = 8192] = "AP";
  ModsEnum2[ModsEnum2["PF"] = 16384] = "PF";
  ModsEnum2[ModsEnum2["K4"] = 32768] = "K4";
  ModsEnum2[ModsEnum2["K5"] = 65536] = "K5";
  ModsEnum2[ModsEnum2["K6"] = 131072] = "K6";
  ModsEnum2[ModsEnum2["K7"] = 262144] = "K7";
  ModsEnum2[ModsEnum2["K8"] = 524288] = "K8";
  ModsEnum2[ModsEnum2["FI"] = 1048576] = "FI";
  ModsEnum2[ModsEnum2["RN"] = 2097152] = "RN";
  ModsEnum2[ModsEnum2["CN"] = 4194304] = "CN";
  ModsEnum2[ModsEnum2["TR"] = 8388608] = "TR";
  ModsEnum2[ModsEnum2["K9"] = 16777216] = "K9";
  ModsEnum2[ModsEnum2["KC"] = 33554432] = "KC";
  ModsEnum2[ModsEnum2["K1"] = 67108864] = "K1";
  ModsEnum2[ModsEnum2["K3"] = 134217728] = "K3";
  ModsEnum2[ModsEnum2["K2"] = 268435456] = "K2";
  ModsEnum2[ModsEnum2["SV2"] = 536870912] = "SV2";
  ModsEnum2[ModsEnum2["MR"] = 1073741824] = "MR";
  return ModsEnum2;
})(ModsEnum || {});
var ScoringTypeEnum = /* @__PURE__ */ ((ScoringTypeEnum2) => {
  ScoringTypeEnum2[ScoringTypeEnum2["Score"] = 0] = "Score";
  ScoringTypeEnum2[ScoringTypeEnum2["Accuracy"] = 1] = "Accuracy";
  ScoringTypeEnum2[ScoringTypeEnum2["Combo"] = 2] = "Combo";
  ScoringTypeEnum2[ScoringTypeEnum2["Score V2"] = 3] = "Score V2";
  return ScoringTypeEnum2;
})(ScoringTypeEnum || {});
var TeamTypeEnum = /* @__PURE__ */ ((TeamTypeEnum2) => {
  TeamTypeEnum2[TeamTypeEnum2["Head To Head"] = 0] = "Head To Head";
  TeamTypeEnum2[TeamTypeEnum2["Tag Co-Op"] = 1] = "Tag Co-Op";
  TeamTypeEnum2[TeamTypeEnum2["Team VS"] = 2] = "Team VS";
  TeamTypeEnum2[TeamTypeEnum2["Tag Team VS"] = 3] = "Tag Team VS";
  return TeamTypeEnum2;
})(TeamTypeEnum || {});
var TeamColorEnum = /* @__PURE__ */ ((TeamColorEnum2) => {
  TeamColorEnum2[TeamColorEnum2["Blue"] = 1] = "Blue";
  TeamColorEnum2[TeamColorEnum2["Red"] = 2] = "Red";
  return TeamColorEnum2;
})(TeamColorEnum || {});

// src/utils/index.ts
function formatUrlParams(urlParams) {
  return Object.entries(urlParams).reduce((prev, [key, value]) => {
    if (!value)
      return prev;
    return Array.isArray(value) ? `${prev}${value.reduce((prev2, value2) => `${prev2}&${key}[]=${value2}`, "")}` : `${prev}&${key}=${value}`;
  }, "");
}
function map(obj) {
  let entries = Object.entries(obj);
  entries = entries.map(mapCallback);
  entries.forEach(([key, value]) => {
    obj[key] = value;
  });
  return obj;
}
function mapCallback([key, value]) {
  let newValue = value;
  if (Array.isArray(value) && typeof value[0] === "object") {
    newValue = value.map((v) => map(v));
  } else if (typeof value === "object" && value) {
    newValue = map(value);
  } else if (!isNaN(Number(value)) && typeof value !== "boolean") {
    newValue = Number(value);
  }
  return [key, newValue];
}
function getModsEnum(mods) {
  return mods.reduce((count, mod) => count + ModsEnum[mod], 0);
}
function getEnumMods(modEnum) {
  let mods = [];
  if (!modEnum || modEnum === "0")
    return mods;
  let parsedGlobalEnum = Number(modEnum);
  let modEnums = Object.keys(ModsEnum);
  modEnums = modEnums.splice(0, modEnums.length / 2);
  for (let i = modEnums.length; parsedGlobalEnum !== 0; i--) {
    let parsedEnum = Number(modEnums[i]);
    if (parsedGlobalEnum - parsedEnum >= 0) {
      mods.push(ModsEnum[parsedEnum]);
      parsedGlobalEnum -= parsedEnum;
    }
  }
  return mods.reverse();
}

// src/classes/Base.ts
var Base2 = class {
  constructor(accessToken) {
    this.axios = import_axios3.default.create({
      baseURL: "https://osu.ppy.sh/api/v2/",
      headers: {
        "Authorization": `Bearer ${import_zod2.z.string().parse(accessToken)}`,
        "Accept-encoding": "*"
      }
    });
  }
  fetch(endpoint, method, options) {
    return __async(this, null, function* () {
      let resp;
      if (options == null ? void 0 : options.query) {
        let query = formatUrlParams(options.query);
        endpoint += query.replace("&", "?");
      }
      if (method === "GET") {
        resp = yield this.axios.get(endpoint);
      } else if (method === "POST") {
        resp = yield this.axios.post(endpoint, options == null ? void 0 : options.body);
      } else {
        resp = yield this.axios.patch(endpoint, options == null ? void 0 : options.body);
      }
      let data = resp.data;
      return data;
    });
  }
};

// src/classes/Users.ts
var import_zod4 = require("zod");

// src/schemas/users.ts
var import_zod3 = require("zod");
var getSelfOptionsSchema = import_zod3.z.object({
  urlParams: import_zod3.z.object({
    /** Gamemode of the proile to return */
    mode: gameModeSchema
  })
}).deepPartial();
var getUserKudosuOptionsSchema = import_zod3.z.object({
  query: import_zod3.z.object(baseQuery)
}).deepPartial();
var userScoreTypeSchema = import_zod3.z.union([
  import_zod3.z.literal("best"),
  import_zod3.z.literal("firsts"),
  import_zod3.z.literal("recent")
]);
var getUserScoresOptions = __spreadProps(__spreadValues({}, baseQuery), {
  /** Gamemode of the scores to return */
  mode: gameModeSchema
});
var getUserScoresOptionsSchema = import_zod3.z.object({
  query: import_zod3.z.object(getUserScoresOptions)
}).deepPartial();
var getUserRecentScoresOptionsSchema = import_zod3.z.object({
  query: import_zod3.z.object(__spreadProps(__spreadValues({}, getUserScoresOptions), {
    /** Include failed scores? */
    include_fails: import_zod3.z.union([import_zod3.z.boolean(), import_zod3.z.number()])
  }))
}).deepPartial();
var getUserBeatmapsOptionsSchema = import_zod3.z.object({
  query: import_zod3.z.object(baseQuery)
}).deepPartial();
var userBeatmapsTypeSchema = import_zod3.z.union([
  import_zod3.z.literal("favourite"),
  import_zod3.z.literal("graveyard"),
  import_zod3.z.literal("guest"),
  import_zod3.z.literal("loved"),
  import_zod3.z.literal("most_played"),
  import_zod3.z.literal("nominated"),
  import_zod3.z.literal("pending"),
  import_zod3.z.literal("ranked")
]);
var getUserRecentActivityOptionsSchema = import_zod3.z.object({
  query: import_zod3.z.object(baseQuery)
}).deepPartial();
var getUserOptionsSchema = import_zod3.z.object({
  urlParams: import_zod3.z.object({
    /** Gamemode of the proile to return */
    mode: gameModeSchema
  }),
  query: import_zod3.z.object({
    /** Specify if the `user` param is an `id` or a `username` */
    key: import_zod3.z.union([import_zod3.z.literal("id"), import_zod3.z.literal("username")])
  })
}).deepPartial();
var getUsersOptionsSchema = import_zod3.z.object({
  query: import_zod3.z.object({
    /** An array of user IDs (can only take up to 50 IDs) */
    ids: import_zod3.z.number().array().max(50)
  })
}).deepPartial();

// src/classes/Users.ts
var Users = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `me` endpoint (requires the `identify` scope)
   * @returns The user corresponding to the access token provided in the constructor of this class
   */
  getSelf(options) {
    return __async(this, null, function* () {
      var _a;
      options = getSelfOptionsSchema.optional().parse(options);
      let endpoint = "me";
      if ((_a = options == null ? void 0 : options.urlParams) == null ? void 0 : _a.mode) {
        endpoint += `/${options.urlParams.mode}`;
      }
      return yield this.fetch(endpoint, "GET");
    });
  }
  /**
   * Makes a GET request to the `/users/{user}/kudosu` endpoint
   * @param user ID of the user to get kudosu from
   * @param options
   * @returns An array containing the specified user's kudosu history
   */
  getUserKudosu(user, options) {
    return __async(this, null, function* () {
      user = import_zod4.z.number().parse(user);
      options = getUserKudosuOptionsSchema.optional().parse(options);
      return yield this.fetch(`users/${user}/kudosu`, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/users/{user}/recent_activity` endpoint
   * @param user ID of the user to get their recent activity from
   * @param options
   * @returns An array containing the specified user's recent activity (each event is a union, to discriminate, use the `type` key)
   */
  getUserRecentActivity(user, options) {
    return __async(this, null, function* () {
      user = import_zod4.z.number().parse(user);
      options = getUserRecentActivityOptionsSchema.optional().parse(options);
      return yield this.fetch(`users/${user}/recent_activity`, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/users/{user}/scores/{type}` endpoint
   * @param user ID of the user to get their scores
   * @param type Score type
   * @param options
   * @returns An array of the specified user's scores
   */
  getUserScores(user, type, options) {
    return __async(this, null, function* () {
      user = import_zod4.z.number().parse(user);
      type = userScoreTypeSchema.parse(type);
      options = type === "recent" ? getUserRecentScoresOptionsSchema.optional().parse(options) : getUserScoresOptionsSchema.optional().parse(options);
      return yield this.fetch(`users/${user}/scores/${type}`, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/users/{user}/beatmapsets/{type}` endpoint
   * @param user ID of the user to get their beatmapsets
   * @param type Type of beatmapsets to return
   * @param options
   * @returns An array of a user's beatmapsets
   */
  getUserBeatmaps(user, type, options) {
    return __async(this, null, function* () {
      user = import_zod4.z.number().parse(user);
      type = userBeatmapsTypeSchema.parse(type);
      options = getUserBeatmapsOptionsSchema.optional().parse(options);
      return yield this.fetch(`users/${user}/beatmapsets/${type}`, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/users/{user}/{mode?}` endpoint
   * @param user ID or username of the user to get
   * @param options
   * @returns A user
   */
  getUser(user, options) {
    return __async(this, null, function* () {
      var _a;
      user = import_zod4.z.union([import_zod4.z.string(), import_zod4.z.number()]).parse(user);
      options = getUserOptionsSchema.optional().parse(options);
      let endpoint = `users/${user}`;
      if ((_a = options == null ? void 0 : options.urlParams) == null ? void 0 : _a.mode) {
        endpoint += `/${options.urlParams.mode}`;
      }
      return yield this.fetch(endpoint, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/users` endpoint
   * @returns An array of users
   */
  getUsers(options) {
    return __async(this, null, function* () {
      options = getUsersOptionsSchema.optional().parse(options);
      let obj = yield this.fetch("users", "GET", options);
      return obj.users;
    });
  }
};

// src/classes/Wiki.ts
var import_zod5 = require("zod");
var Wiki = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/wiki/{locale}/{path}` endpoint
   * @param locale Two-letter language code of the wiki page
   * @param path Path to the wiki page
   * @returns The wiki page
   */
  getWikiPage(locale, path) {
    return __async(this, null, function* () {
      locale = import_zod5.z.string().length(2).parse(locale);
      path = import_zod5.z.string().parse(path);
      return yield this.fetch(`wiki/${locale}/${path}`, "GET");
    });
  }
};

// src/schemas/comments.ts
var import_zod6 = require("zod");
var commentSortSchema = import_zod6.z.union([import_zod6.z.literal("new"), import_zod6.z.literal("old"), import_zod6.z.literal("top")]);
var commentableTypeSchema = import_zod6.z.union([
  import_zod6.z.literal("beatmapset"),
  import_zod6.z.literal("news_post"),
  import_zod6.z.literal("build")
]);
var getCommentsOptionsSchema = import_zod6.z.object({
  query: import_zod6.z.object({
    /** Resource to get comments for */
    commentable: import_zod6.z.object({
      /** Type of the resource */
      type: commentableTypeSchema,
      /** ID of the resource */
      id: import_zod6.z.number()
    }),
    /** Get replies of a specific comment ID */
    parent_id: import_zod6.z.number(),
    /** Sort option */
    sort: commentSortSchema
  })
}).deepPartial();

// src/classes/Comments.ts
var import_zod7 = require("zod");
var Comments = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/comments` endpoint
   * @returns An object containing comments, users and other related data
   */
  getComments(options) {
    return __async(this, null, function* () {
      options = getCommentsOptionsSchema.optional().transform((options2) => {
        var _a, _b, _c, _d;
        let query = options2 == null ? void 0 : options2.query;
        if (query == null ? void 0 : query.commentable) {
          query = __spreadProps(__spreadValues({}, query), {
            commentable_type: (_b = (_a = options2 == null ? void 0 : options2.query) == null ? void 0 : _a.commentable) == null ? void 0 : _b.type,
            commentable_id: (_d = (_c = options2 == null ? void 0 : options2.query) == null ? void 0 : _c.commentable) == null ? void 0 : _d.id
          });
          delete query.commentable;
        }
        return { query };
      }).parse(options);
      return yield this.fetch("comments", "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/comments/{comment}` endpoint
   * @param comment ID of the comment to get related data from
   * @returns An object containing comments, users and other related data to the comment with the specified ID
   */
  getComment(comment) {
    return __async(this, null, function* () {
      comment = import_zod7.z.number().parse(comment);
      return yield this.fetch(`comments/${comment}`, "GET");
    });
  }
};

// src/schemas/multiplayer.ts
var import_zod8 = require("zod");
var multiplayerScoresSortSchema = import_zod8.z.union([
  import_zod8.z.literal("score_asc"),
  import_zod8.z.literal("score_desc")
]);
var getPlaylistScoresOptionsSchema = import_zod8.z.object({
  query: import_zod8.z.object({
    /** Limit number of results */
    limit: import_zod8.z.number(),
    /** Sort option */
    sort: multiplayerScoresSortSchema,
    /** Pagination cursor */
    cursor_string: import_zod8.z.string()
  })
}).deepPartial();

// src/classes/Multiplayer.ts
var import_zod9 = require("zod");
var Multiplayer = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/rooms/{room}/playlist/{playlist}/scores` endpoint
   * @param room ID of the room corresponding to the playlist
   * @param playlist ID of the playlist to get scores from
   * @returns An object containing playlist scores and metadata
   */
  getPlaylistScores(room, playlist, options) {
    return __async(this, null, function* () {
      room = import_zod9.z.number().parse(room);
      playlist = import_zod9.z.number().parse(playlist);
      options = getPlaylistScoresOptionsSchema.optional().parse(options);
      return yield this.fetch(`rooms/${room}/playlist/${playlist}/scores`, "GET", options);
    });
  }
};

// src/schemas/ranking.ts
var import_zod10 = require("zod");
var rankingTypeSchema = import_zod10.z.union([
  import_zod10.z.literal("charts"),
  import_zod10.z.literal("country"),
  import_zod10.z.literal("performance"),
  import_zod10.z.literal("score")
]);
var getRankingOptionsSchema = import_zod10.z.object({
  query: import_zod10.z.object({
    /** Filter by country code (only available for type `performance`) */
    country: import_zod10.z.string().length(2).transform((str) => str.toUpperCase()),
    /** Show all users or friend ranking */
    filter: import_zod10.z.union([import_zod10.z.literal("all"), import_zod10.z.literal("friends")]),
    /** ID of the spotlight (if type is `charts`) */
    spotlight: import_zod10.z.number(),
    /** Filter ranking by specified mode variant (only available for type `performance`) */
    variant: import_zod10.z.string()
  })
}).deepPartial();

// src/classes/Ranking.ts
var Ranking = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/rankings/{mode}/{type}` endpoint
   * @param mode Ranking gamemode
   * @param type Ranking type
   * @returns An object containing ranking data
   */
  getRanking(mode, type, options) {
    return __async(this, null, function* () {
      mode = gameModeSchema.parse(mode);
      type = rankingTypeSchema.parse(type);
      options = getRankingOptionsSchema.optional().parse(options);
      return yield this.fetch(`rankings/${mode}/${type}`, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/spotights` endpoint
   * @returns An array of spotlights
   */
  getSpotlights() {
    return __async(this, null, function* () {
      let spotlights = yield this.fetch("spotlights", "GET");
      return spotlights.spotlights;
    });
  }
};

// src/classes/News.ts
var import_zod12 = require("zod");

// src/schemas/news.ts
var import_zod11 = require("zod");
var getNewsListingOptionsSchema = import_zod11.z.object({
  query: import_zod11.z.object({
    /** Limit number of results */
    limit: import_zod11.z.number(),
    /** Filter news posts by a specific year */
    year: import_zod11.z.number(),
    /** Pagination cursor */
    cursor_string: import_zod11.z.string()
  })
}).deepPartial();
var getNewsPostOptionsSchema = import_zod11.z.object({
  query: import_zod11.z.object({
    /** Specify whether the query must be done with a news post ID (`id`) or a slug (unset value) */
    key: import_zod11.z.literal("id")
  })
}).deepPartial();

// src/classes/News.ts
var News = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/news` endpoint
   * @returns An object containing news posts and other additional data
   */
  getNewsListing(options) {
    return __async(this, null, function* () {
      options = getNewsListingOptionsSchema.optional().parse(options);
      return yield this.fetch("news", "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/news/{news}` endpoint
   * @param news ID or slug of the news post to get
   * @returns A news post
   */
  getNewsPost(news, options) {
    return __async(this, null, function* () {
      news = import_zod12.z.union([import_zod12.z.string(), import_zod12.z.number()]).parse(news);
      options = getNewsPostOptionsSchema.optional().parse(options);
      return yield this.fetch(`news/${news}`, "GET", options);
    });
  }
};

// src/classes/Beatmaps.ts
var import_zod14 = require("zod");

// src/schemas/beatmaps.ts
var import_zod13 = require("zod");
var lookupBeatmapOptionsSchema = import_zod13.z.object({
  query: import_zod13.z.object({
    /** A beatmap checksum */
    checksum: import_zod13.z.string(),
    /** A beatmap file name */
    filename: import_zod13.z.string(),
    /** ID of a beatmap */
    id: import_zod13.z.number()
  })
}).deepPartial();
var getBeatmapScoresOptionSchema = import_zod13.z.object({
  query: import_zod13.z.object({
    /** Gamemode of the scores to return */
    mode: gameModeSchema
  })
}).deepPartial();
var getBeatmapsOptionsSchema = import_zod13.z.object({
  query: import_zod13.z.object({
    /** An array of beatmap IDs (can only take up to 50 IDs) */
    ids: import_zod13.z.number().array().max(50)
  })
}).deepPartial();
var getBeatmapOptionsSchema = import_zod13.z.object({
  query: import_zod13.z.object({
    /** A beatmap ID */
    id: import_zod13.z.number()
  })
}).deepPartial();
var getBeatmapAttributesOptionsSchema = import_zod13.z.object({
  body: import_zod13.z.object({
    /** Mods to apply (can be either the bitwise representation or an array of acronyms) */
    mods: import_zod13.z.union([import_zod13.z.number(), modsSchema])
  })
}).deepPartial();

// src/classes/Beatmaps.ts
var import_axios4 = require("axios");
var Beatmaps = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/beatmaps/lookup` endpoint
   * @returns A beatmap
   */
  lookupBeatmap(options) {
    return __async(this, null, function* () {
      var _a;
      options = lookupBeatmapOptionsSchema.optional().parse(options);
      let beatmap;
      try {
        beatmap = yield this.fetch("beatmaps/lookup", "GET", options);
      } catch (err) {
        if (!(0, import_axios4.isAxiosError)(err) || ((_a = err.response) == null ? void 0 : _a.status) !== 404) {
          throw err;
        }
      }
      return beatmap;
    });
  }
  /**
   * Makes a GET request to the `/beatmaps/{beatmap}/scores/users/{user}` endpoint
   * @param beatmap ID of the beatmap to get scores from
   * @param user ID of the user to get scores from
   * @returns A user score on a beatmap
   */
  getBeatmapUserScore(beatmap, user, options) {
    return __async(this, null, function* () {
      beatmap = import_zod14.z.number().parse(beatmap);
      user = import_zod14.z.number().parse(user);
      options = getBeatmapScoresOptionSchema.optional().parse(options);
      return yield this.fetch(`beatmaps/${beatmap}/scores/users/${user}`, "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/beatmaps/{beatmap}/scores/users/{user}/all` endpoint
   * @param beatmap ID of the beatmap to get scores from
   * @param user ID of the user to get scores from
   * @returns An array of user scores on a beatmap
   */
  getBeatmapUserScores(beatmap, user, options) {
    return __async(this, null, function* () {
      beatmap = import_zod14.z.number().parse(beatmap);
      user = import_zod14.z.number().parse(user);
      options = getBeatmapScoresOptionSchema.optional().parse(options);
      let scores = yield this.fetch(`beatmaps/${beatmap}/scores/users/${user}/all`, "GET", options);
      return scores.scores;
    });
  }
  /**
   * Makes a GET request to the `/beatmaps/{beatmap}/scores` endpoint
   * @param beatmap ID of the beatmap to get top scores from
   * @returns An array of user scores on a beatmap
   */
  getBeatmapTopScores(beatmap, options) {
    return __async(this, null, function* () {
      beatmap = import_zod14.z.number().parse(beatmap);
      options = getBeatmapScoresOptionSchema.optional().parse(options);
      let scores = yield this.fetch(`beatmaps/${beatmap}/scores`, "GET", options);
      return scores.scores;
    });
  }
  /**
   * Makes a GET request to the `/beatmaps` endpoint
   * @returns An array of beatmaps
   */
  getBeatmaps(options) {
    return __async(this, null, function* () {
      options = getBeatmapsOptionsSchema.optional().parse(options);
      let beatmaps = yield this.fetch("/beatmaps", "GET", options);
      return beatmaps.beatmaps;
    });
  }
  /**
   * Makes a GET request to the `/beatmaps/{beatmap}` endpoint
   * @param beatmap ID of the beatmap to get
   * @returns A beatmap
   */
  getBeatmap(beatmap) {
    return __async(this, null, function* () {
      beatmap = import_zod14.z.number().parse(beatmap);
      return yield this.fetch(`beatmaps/${beatmap}`, "GET");
    });
  }
  /**
   * Makes a POST request to the `/beatmaps/{beatmap}/attributes` endpoint
   * @param beatmap ID of the beatmap to get its attributes
   * @param gamemode Gamemode attributes to get
   * @returns A beatmap's attributes
   */
  getBeatmapAttributes(beatmap, gamemode, options) {
    return __async(this, null, function* () {
      var _a;
      beatmap = import_zod14.z.number().parse(beatmap);
      gamemode = gameModeSchema.parse(gamemode);
      options = getBeatmapAttributesOptionsSchema.optional().parse(options);
      let remapped = {
        body: {
          mods: (_a = options == null ? void 0 : options.body) == null ? void 0 : _a.mods,
          ruleset: gamemode
        }
      };
      return yield this.fetch(`beatmaps/${beatmap}/attributes`, "POST", remapped);
    });
  }
};

// src/classes/Changelog.ts
var import_zod16 = require("zod");

// src/schemas/changelog.ts
var import_zod15 = require("zod");
var changelogStreamSchema = import_zod15.z.union([
  import_zod15.z.literal("stable40"),
  import_zod15.z.literal("beta40"),
  import_zod15.z.literal("cuttingedge"),
  import_zod15.z.literal("lazer"),
  import_zod15.z.literal("web")
]);
var messageFormatsSchema = import_zod15.z.union([import_zod15.z.literal("html"), import_zod15.z.literal("markdown")]).array();
var getChangelogListingOptionsSchema = import_zod15.z.object({
  query: import_zod15.z.object({
    /** Minimum build version */
    from: import_zod15.z.string(),
    /** Maximum build ID */
    max_id: import_zod15.z.number(),
    /** Stream name to return builds from */
    stream: changelogStreamSchema,
    /** Maximum build version */
    to: import_zod15.z.string(),
    /** Changelog entry format (returns both by default) */
    message_formats: messageFormatsSchema
  })
}).deepPartial();
var lookupChangelogBuildOptionsSchema = import_zod15.z.object({
  query: import_zod15.z.object({
    /** Unset to query by build version or stream name, or id to query by build ID */
    key: import_zod15.z.literal("id"),
    /** Changelog entry format (returns both by default) */
    message_formats: messageFormatsSchema
  })
}).deepPartial();

// src/classes/Changelog.ts
var import_axios5 = require("axios");
var Changelog = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/changelog/{stream}/{build}` endpoint
   * @param stream Update stream name
   * @param build Build version
   * @returns A changelog build
   */
  getChangelogBuild(stream, build) {
    return __async(this, null, function* () {
      stream = changelogStreamSchema.parse(stream);
      build = import_zod16.z.string().parse(build);
      return yield this.fetch(`changelog/${stream}/${build}`, "GET");
    });
  }
  /**
   * Makes a GET request to the `/changelog` endpoint
   * @returns An object containing a array of builds, update stream and search parameters used
   */
  getChangelogListing(options) {
    return __async(this, null, function* () {
      options = getChangelogListingOptionsSchema.optional().parse(options);
      return yield this.fetch("changelog", "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/changelog/{changelog}` endpoint
   * @param changelog Build version, update stream name, or build ID
   * @returns A changelog build
   */
  lookupChangelogBuild(changelog, options) {
    return __async(this, null, function* () {
      var _a;
      changelog = import_zod16.z.union([import_zod16.z.string(), import_zod16.z.number()]).parse(changelog);
      options = lookupChangelogBuildOptionsSchema.optional().parse(options);
      let build;
      try {
        build = yield this.fetch(`changelog/${changelog}`, "GET", options);
      } catch (err) {
        if (!(0, import_axios5.isAxiosError)(err) || ((_a = err.response) == null ? void 0 : _a.status) !== 404) {
          throw err;
        }
      }
      return build;
    });
  }
};

// src/classes/Chat.ts
var import_zod18 = require("zod");

// src/schemas/chat.ts
var import_zod17 = require("zod");
var createPMOptionsSchema = import_zod17.z.object({
  body: import_zod17.z.object({
    /** ID of the user to send a PM */
    target_id: import_zod17.z.number(),
    /** Message to send */
    message: import_zod17.z.string(),
    /** Is the message an action? */
    is_action: import_zod17.z.boolean().default(false).optional(),
    /** Client side message identifier which will be sent back in response and websocket JSON */
    uuid: import_zod17.z.string().uuid().optional()
  })
});
var channelDetails = {
  /** Channel name */
  name: import_zod17.z.string(),
  /** Channel description */
  description: import_zod17.z.string()
};
var createPMChannelOptionsSchema = import_zod17.z.object({
  body: import_zod17.z.object({
    /** Message to send */
    message: import_zod17.z.string().optional(),
    /** Channel details */
    channel: import_zod17.z.object(channelDetails).partial().optional(),
    /** Target user ID */
    target_id: import_zod17.z.number()
  })
});
var createAnnounceChannelOptionsSchema = import_zod17.z.object({
  body: import_zod17.z.object({
    /** Message to send with the announcement */
    message: import_zod17.z.string(),
    /** Channel details */
    channel: import_zod17.z.object(channelDetails),
    /** Target user IDs */
    target_ids: import_zod17.z.number().array()
  })
});

// src/classes/Chat.ts
var Chat = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a POST request to the `/chat/new` endpoint
   * @returns An object containing the message sent and the channel it was sent to
   */
  createPM(options) {
    return __async(this, null, function* () {
      options = createPMOptionsSchema.parse(options);
      return yield this.fetch("chat/new", "POST", options);
    });
  }
  /**
   * Makes a POST request to the `/chat/channels` endpoint
   * @param type Channel type to create or rejoin
   * @returns The created or rejoined channel
   */
  createChannel(type, options) {
    return __async(this, null, function* () {
      type = import_zod18.z.union([import_zod18.z.literal("PM"), import_zod18.z.literal("ANNOUNCE")]).parse(type);
      let parsed = type === "PM" ? createPMChannelOptionsSchema.parse(options) : createAnnounceChannelOptionsSchema.parse(options);
      let remapped = {
        body: __spreadProps(__spreadValues({}, parsed.body), {
          type
        })
      };
      return yield this.fetch("chat/channels", "POST", remapped);
    });
  }
};

// src/classes/Forum.ts
var import_zod20 = require("zod");

// src/schemas/forum.ts
var import_zod19 = require("zod");
var replyToTopicOptionsSchema = import_zod19.z.object({
  body: import_zod19.z.object({
    /** Content of the reply */
    body: import_zod19.z.string()
  })
});
var createTopicOptionsSchema = import_zod19.z.object({
  body: import_zod19.z.object({
    /** Content of the topic */
    body: import_zod19.z.string(),
    /** ID of the forum to create the topic in */
    forum_id: import_zod19.z.number(),
    /** Title of the topic */
    title: import_zod19.z.string(),
    /** Create a poll with the topic? */
    with_poll: import_zod19.z.boolean().optional(),
    /** Poll details */
    forum_topic_poll: import_zod19.z.object({
      /** Hide result (until voting period ends)? */
      hide_results: import_zod19.z.boolean().default(false).optional(),
      /** Length of the voting period in days. 0 means that the voting will never end. This parameter is required if `hide_results` option is enabled */
      length_days: import_zod19.z.number().gte(0).default(0).optional(),
      /** Max. number of votes each user can cast */
      max_options: import_zod19.z.number().gte(1).default(1).optional(),
      /** Newline-separated list of voting options. BBCode is supported */
      options: import_zod19.z.string(),
      /** Title of the poll */
      title: import_zod19.z.string(),
      /** Can a user change their votes? */
      vote_change: import_zod19.z.boolean().default(false).optional()
    }).optional()
  })
});
var getTopicOptionsSchema = import_zod19.z.object({
  query: import_zod19.z.object({
    /** Pagination cursor */
    cursor_string: import_zod19.z.string(),
    /** Sort posts by */
    sort: import_zod19.z.union([import_zod19.z.literal("id_asc"), import_zod19.z.literal("id_desc")]),
    /** Max. number of posts to be returned (caps at 50) */
    limit: import_zod19.z.number().lte(50),
    /** First post ID to be returned with `sort` set to `id_asc`. This parameter is ignored if `cursor_string` is specified */
    start: import_zod19.z.number(),
    /** First post ID to be returned with `sort` set to `id_desc`. This parameter is ignored if `cursor_string` is specified */
    end: import_zod19.z.number()
  })
}).deepPartial();
var updateTopicOptionsSchema = import_zod19.z.object({
  body: import_zod19.z.object({
    /** Forum topic details */
    forum_topic: import_zod19.z.object({
      /** Title of the topic */
      topic_title: import_zod19.z.string()
    })
  })
}).deepPartial();
var updatePostOptionsSchema = import_zod19.z.object({
  body: import_zod19.z.object({
    /** Content of the post in BBCode format */
    body: import_zod19.z.string()
  })
});

// src/classes/Forum.ts
var Forum = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a POST request to the `/forums/topics/{topic}/reply` endpoint
   * @param topic ID of the topic to reply to
   * @returns A forum post
   */
  replyToTopic(topic, options) {
    return __async(this, null, function* () {
      topic = import_zod20.z.number().parse(topic);
      options = replyToTopicOptionsSchema.parse(options);
      return yield this.fetch(`forums/topics/${topic}/reply`, "POST", options);
    });
  }
  /**
   * Makes a POST request to the `/forums/topics` endpoint
   * @returns A forum topic and the post attached to it
   */
  createTopic(options) {
    return __async(this, null, function* () {
      options = createTopicOptionsSchema.parse(options);
      let poll = options.body.forum_topic_poll;
      let parsedPoll;
      if (poll) {
        parsedPoll = {};
        for (let key in poll) {
          parsedPoll[`forum_topic_poll[${key}]`] = poll[key];
        }
      }
      let parsed = {
        body: __spreadValues(__spreadValues({}, options.body), parsedPoll)
      };
      delete parsed.body.forum_topic_poll;
      return yield this.fetch("forums/topics", "POST", parsed);
    });
  }
  /**
   * Makes a GET request to the `/forums/topics/{topic}` endpoint
   * @param topic ID of the topic to get its data and posts from
   * @returns An object containing the cursor string, posts and the topic itself
   */
  getTopic(topic, options) {
    return __async(this, null, function* () {
      topic = import_zod20.z.number().parse(topic);
      options = getTopicOptionsSchema.optional().parse(options);
      return yield this.fetch(`forums/topics/${topic}`, "GET", options);
    });
  }
  /**
   * Makes a PATCH request to the `/forums/topics/{topic}` endpoint
   * @param topic ID of the topic to update
   * @returns A forum topic
   */
  updateTopic(topic, options) {
    return __async(this, null, function* () {
      var _a, _b;
      topic = import_zod20.z.number().parse(topic);
      options = updateTopicOptionsSchema.optional().parse(options);
      let forumTopic = (_a = options == null ? void 0 : options.body) == null ? void 0 : _a.forum_topic;
      let parsedForumTopic;
      if (forumTopic) {
        parsedForumTopic = {};
        for (let key in forumTopic) {
          parsedForumTopic[`forum_topic[${key}]`] = forumTopic[key];
        }
      }
      let parsed = {
        // prettier-ignore
        body: (options == null ? void 0 : options.body) ? __spreadValues(__spreadValues({}, options.body), parsedForumTopic) : void 0
      };
      (_b = parsed.body) == null ? true : delete _b.forum_topic;
      return yield this.fetch(`forums/topics/${topic}`, "PATCH", parsed);
    });
  }
  /**
   * Makes a PATCH request to the `/forums/posts/{post}` endpoint
   * @param post ID of the post to update
   * @returns A forum post
   */
  updatePost(post, options) {
    return __async(this, null, function* () {
      post = import_zod20.z.number().parse(post);
      options = updatePostOptionsSchema.parse(options);
      return yield this.fetch(`forums/posts/${post}`, "PATCH", options);
    });
  }
};

// src/schemas/beatmapset-discussions.ts
var import_zod21 = require("zod");
var baseQuerySchema = {
  /** Max. number of results */
  limit: import_zod21.z.number(),
  /** Search result page number */
  page: import_zod21.z.number(),
  /** Sort posts by newest (`id_desc`) or oldest (`id_desc`) */
  sort: import_zod21.z.union([import_zod21.z.literal("id_desc"), import_zod21.z.literal("id_asc")])
};
var getDiscussionPostsOptionsSchema = import_zod21.z.object({
  query: import_zod21.z.object(__spreadProps(__spreadValues({}, baseQuerySchema), {
    /** ID of the beatmapset discussion */
    beatmapset_discussion_id: import_zod21.z.number(),
    /** Post types */
    types: import_zod21.z.union([import_zod21.z.literal("first"), import_zod21.z.literal("reply"), import_zod21.z.literal("system")]).array(),
    /** ID of the user to get posts from */
    user: import_zod21.z.number()
  }))
}).deepPartial();
var getDiscussionVotesOptionsSchema = import_zod21.z.object({
  query: import_zod21.z.object(__spreadProps(__spreadValues({}, baseQuerySchema), {
    /** ID of the beatmapset discussion */
    beatmapset_discussion_id: import_zod21.z.number(),
    /** ID of the user receiving the votes */
    receiver: import_zod21.z.number(),
    /** `1` for up vote, `-1` for down vote */
    score: import_zod21.z.union([import_zod21.z.literal(1), import_zod21.z.literal(-1)]),
    /** ID of the user giving votes */
    user: import_zod21.z.number()
  }))
}).deepPartial();
var discussionMessageTypeSchema = import_zod21.z.union([
  import_zod21.z.literal("suggestion"),
  import_zod21.z.literal("problem"),
  import_zod21.z.literal("mapper_note"),
  import_zod21.z.literal("praise"),
  import_zod21.z.literal("hype"),
  import_zod21.z.literal("review")
]);
var getDiscussionsOptionsSchema = import_zod21.z.object({
  query: import_zod21.z.object(__spreadProps(__spreadValues({}, baseQuerySchema), {
    /** ID of the beatmap to get discussions from */
    beatmap_id: import_zod21.z.number(),
    /** ID of the beatmapset to get discussions from */
    beatmapset_id: import_zod21.z.number(),
    /** Specify beatmapset status */
    beatmapset_status: import_zod21.z.union([
      import_zod21.z.literal("all"),
      import_zod21.z.literal("ranked"),
      import_zod21.z.literal("qualified"),
      import_zod21.z.literal("disqualified"),
      import_zod21.z.literal("never_qualified")
    ]),
    /** Specify message types, (unset for all) */
    message_types: discussionMessageTypeSchema.array(),
    /** Show only resolved issues? */
    only_unresolved: import_zod21.z.boolean(),
    /** ID of the user (documentation doesn't specify about what) */
    user: import_zod21.z.number()
  }))
}).deepPartial();

// src/classes/BeatmapsetDiscussions.ts
var BeatmapsetDiscussions = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    super(accessToken);
  }
  /**
   * Makes a GET request to the `/beatmapsets/discussions/posts` endpoint
   * @returns An object containing a cursor and arrays of beatmapsets, users, discussions and posts
   */
  getDiscussionPosts(options) {
    return __async(this, null, function* () {
      options = getDiscussionPostsOptionsSchema.optional().parse(options);
      return yield this.fetch("beatmapsets/discussions/posts", "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/beatmapsets/discussions/votes` endpoint
   * @returns An object containing a cursor and arrays of discussions, users and votes
   */
  getDiscussionVotes(options) {
    return __async(this, null, function* () {
      options = getDiscussionVotesOptionsSchema.optional().parse(options);
      return yield this.fetch("beatmapsets/discussions/votes", "GET", options);
    });
  }
  /**
   * Makes a GET request to the `/beatmapsets/discussions` endpoint
   * @returns An object containing a cursor and arrays of beatmaps, discussions and users
   */
  getDiscussions(options) {
    return __async(this, null, function* () {
      options = getDiscussionsOptionsSchema.optional().parse(options);
      return yield this.fetch("beatmapsets/discussions", "GET", options);
    });
  }
};

// src/classes/Client.ts
var Client = class extends Base2 {
  /**
   * @param accessToken OAuth access token
   */
  constructor(accessToken) {
    let token = accessToken;
    super(token);
    this.beatmaps = new Beatmaps(token);
    this.beatmapsetDiscussions = new BeatmapsetDiscussions(token);
    this.changelog = new Changelog(token);
    this.chat = new Chat(token);
    this.comments = new Comments(token);
    this.forum = new Forum(token);
    this.multiplayer = new Multiplayer(token);
    this.news = new News(token);
    this.ranking = new Ranking(token);
    this.users = new Users(token);
    this.wiki = new Wiki(token);
  }
  /**
   * Makes a GET request to the `/search` endpoint
   * @returns Users and wiki pages as results
   */
  search(options) {
    return __async(this, null, function* () {
      options = searchOptionsSchema.optional().parse(options);
      return yield this.fetch("search", "GET", options);
    });
  }
  /**
   * Make a GET request to an undocumented endpoint
   * @param endpoint The endpoint to make a request to
   */
  getUndocumented(endpoint, options) {
    return __async(this, null, function* () {
      return yield this.fetch(endpoint, "GET", options);
    });
  }
};

// src/schemas/legacy.ts
var import_zod22 = require("zod");
var userTypeSchema = import_zod22.z.union([import_zod22.z.literal("string"), import_zod22.z.literal("id")]).optional();
var getBeatmapsParamsSchema = import_zod22.z.object({
  /** Beatmaps ranked or loved since this date (in UTC) */
  since: import_zod22.z.date().optional(),
  /** Beatmaps with a specific beatmapset ID */
  s: import_zod22.z.number().optional(),
  /** Beatmap with a specific beatmap ID */
  b: import_zod22.z.number().optional(),
  /** Beatmaps created by user with a specific user ID or username */
  u: import_zod22.z.union([import_zod22.z.string(), import_zod22.z.number()]).optional(),
  /** Specify if `u` is a user ID (`id`) or a username (`string`) */
  type: userTypeSchema,
  /** Beatmaps from a specific gamemode */
  m: gameModeSchema.optional(),
  /** Include converted beatmaps? */
  a: import_zod22.z.boolean().optional(),
  /** Beatmap with a specific hash */
  h: import_zod22.z.string().optional(),
  /** Limit amount of beatmaps to return (500 max.) */
  limit: import_zod22.z.number().gte(0).lte(500).optional(),
  /** Mods to apply */
  mods: modsSchema.optional()
});
var getUserParamsSchema = import_zod22.z.object({
  /** User with a specific user ID or username */
  u: import_zod22.z.union([import_zod22.z.string(), import_zod22.z.number()]).optional(),
  /** User gamemode profile  */
  m: gameModeSchema.optional(),
  /** Specify if `u` is a user ID (`id`) or a username (`string`) */
  type: userTypeSchema,
  /** Max. number of days between now and the last event's date (range: 1-31) */
  event_days: import_zod22.z.number().gte(1).lte(31).optional()
});
var getUserScores = {
  /** Scores from a specific gamemode  */
  m: gameModeSchema.optional(),
  /** Limit amount of scores to return (100 max.) */
  limit: import_zod22.z.number().gte(1).lte(100).optional(),
  /** Specify if `u` is a user ID (`id`) or a username (`string`) */
  type: userTypeSchema
};
var getBeatmapScoresParamsSchema = import_zod22.z.object(__spreadProps(__spreadValues({}, getUserScores), {
  /** Scores from a beatmap with a specific beatmap ID */
  b: import_zod22.z.number(),
  /** Scores from a user with a specific user ID or username */
  u: import_zod22.z.union([import_zod22.z.string(), import_zod22.z.number()]).optional()
}));
var getUserScoresParamsSchema = import_zod22.z.object(__spreadProps(__spreadValues({}, getUserScores), {
  /** Scores from a user with a specific user ID or username */
  u: import_zod22.z.union([import_zod22.z.string(), import_zod22.z.number()])
}));
var getMultiplayerLobbyParamsSchema = import_zod22.z.object({
  /** Match with a specific match ID */
  mp: import_zod22.z.number()
});
var getReplayParams = {
  /** Replay gamemode */
  m: gameModeSchema.optional(),
  /** Replay with a specific list of mods */
  mods: modsSchema.optional()
};
var getReplayByScoreIdParamsSchema = import_zod22.z.object(__spreadProps(__spreadValues({}, getReplayParams), {
  /** Replay from a score with a specific score ID */
  s: import_zod22.z.number()
}));
var getReplayByBeatmapAndUserIdParamsSchema = import_zod22.z.object(__spreadProps(__spreadValues({}, getReplayParams), {
  /** Replay from a beatmap with a specific beatmap ID */
  b: import_zod22.z.number(),
  /** Replay from a user with a specific user ID or username */
  u: import_zod22.z.union([import_zod22.z.string(), import_zod22.z.number()]),
  /** Specify if `u` is a user ID (`id`) or a username (`string`) */
  type: userTypeSchema
}));

// src/classes/LegacyClient.ts
var import_zod23 = require("zod");
var import_axios6 = __toESM(require("axios"), 1);
var LegacyClient = class {
  /**
   * @param apiKey API key
   */
  constructor(apiKey) {
    this.apiKey = import_zod23.z.string().parse(apiKey);
  }
  fetch(endpoint, urlParams) {
    return __async(this, null, function* () {
      let params = formatUrlParams(urlParams);
      let url = `https://osu.ppy.sh/api/${endpoint}?k=${this.apiKey}${params}`;
      let resp = yield import_axios6.default.get(url, {
        headers: {
          "Accept-encoding": "*"
        }
      });
      let data = resp.data;
      return data;
    });
  }
  /**
   * Makes a GET request to the `get_beatmaps` endpoint
   * @returns An array of beatmaps
   */
  getBeatmaps(params) {
    return __async(this, null, function* () {
      var _a;
      let parsed = getBeatmapsParamsSchema.parse(params);
      let mods = parsed.mods ? parsed.mods : [];
      let diffIncreaseMods = mods.filter((mod) => {
        return ["HD", "HR", "DT", "FL", "FI"].includes(mod);
      });
      let validParams = __spreadProps(__spreadValues({}, parsed), {
        since: (_a = parsed.since) == null ? void 0 : _a.toISOString().slice(0, 19).replace("T", " "),
        m: parsed.m && ModesEnum[parsed.m],
        a: Number(parsed.a),
        mods: getModsEnum(diffIncreaseMods)
      });
      let beatmaps = yield this.fetch("get_beatmaps", validParams);
      return beatmaps.map((beatmap) => {
        return map(__spreadProps(__spreadValues({}, beatmap), {
          approved: StatusEnum[Number(beatmap.approved)],
          genre: GenresEnum[Number(beatmap.genre_id)],
          language: LanguagesEnum[Number(beatmap.language_id)],
          mode: ModesEnum[Number(beatmap.mode)],
          storyboard: beatmap.storyboard === "1",
          video: beatmap.video === "1",
          download_available: beatmap.download_unavailable === "0",
          audio_available: beatmap.audio_unavailable === "0",
          tags: beatmap.tags.split(" ")
        }));
      });
    });
  }
  /**
   * Makes a GET request to the `get_user` endpoint
   * @returns A user if it exists, otherwise null
   */
  getUser(params) {
    return __async(this, null, function* () {
      let parsed = getUserParamsSchema.parse(params);
      let validParams = __spreadProps(__spreadValues({}, parsed), {
        m: parsed.m && ModesEnum[parsed.m]
      });
      let users = yield this.fetch("get_user", validParams);
      return users.length > 0 ? map(users[0]) : null;
    });
  }
  /**
   * Makes a GET request to the `get_scores` endpoint
   * @returns An array of scores on a beatmap
   */
  getBeatmapScores(params) {
    return __async(this, null, function* () {
      let parsed = getBeatmapScoresParamsSchema.parse(params);
      let validParams = __spreadProps(__spreadValues({}, parsed), {
        m: parsed.m && ModesEnum[parsed.m]
      });
      let scores = yield this.fetch("get_scores", validParams);
      return scores.map((score) => {
        return map(__spreadProps(__spreadValues({}, score), {
          replay_available: score.replay_available === "1",
          enabled_mods: getEnumMods(score.enabled_mods),
          perfect: score.perfect === "1"
        }));
      });
    });
  }
  getUserScores(type, params) {
    return __async(this, null, function* () {
      let parsed = getUserScoresParamsSchema.parse(params);
      let validParams = __spreadProps(__spreadValues({}, parsed), {
        m: parsed.m && ModesEnum[parsed.m]
      });
      let scores = yield this.fetch(
        `get_user_${type}`,
        validParams
      );
      if (type === "best") {
        let userScores = scores;
        return userScores.map((score) => {
          return map(__spreadProps(__spreadValues({}, score), {
            perfect: score.perfect === "1",
            enabled_mods: getEnumMods(score.enabled_mods),
            replay_available: score.replay_available === "1"
          }));
        });
      } else {
        let userScores = scores;
        return userScores.map((score) => {
          return map(__spreadProps(__spreadValues({}, score), {
            perfect: score.perfect === "1",
            enabled_mods: getEnumMods(score.enabled_mods)
          }));
        });
      }
    });
  }
  /**
   * Makes a GET request to the `get_user_best` endpoint
   * @returns An array of a user's top scores
   */
  getUserBestScores(params) {
    return __async(this, null, function* () {
      return yield this.getUserScores("best", params);
    });
  }
  /**
   * Makes a GET request to the `get_user_recent` endpoint
   * @returns An array of a user's most recent scores in 24 hours
   */
  getUserRecentScores(params) {
    return __async(this, null, function* () {
      return yield this.getUserScores("recent", params);
    });
  }
  /**
   * Makes a GET request to the `get_match` endpoint
   * @returns An object containing the match's information, games and each games' scores if the multiplayer lobby exists, otherwise null
   */
  getMultiplayerLobby(params) {
    return __async(this, null, function* () {
      let parsed = getMultiplayerLobbyParamsSchema.parse(params);
      let mpLobby = yield this.fetch("get_match", parsed);
      if (!mpLobby.match)
        return null;
      return map(__spreadProps(__spreadValues({}, mpLobby), {
        games: mpLobby.games.map((game) => {
          return __spreadProps(__spreadValues({}, game), {
            play_mode: ModesEnum[Number(game.play_mode)],
            scoring_type: ScoringTypeEnum[Number(game.scoring_type)],
            team_type: TeamTypeEnum[Number(game.team_type)],
            mods: getEnumMods(game.mods),
            scores: game.scores.map((score) => {
              delete score.rank;
              return __spreadProps(__spreadValues({}, score), {
                team: score.team === "0" ? null : TeamColorEnum[Number(score.team)],
                perfect: score.perfect === "1",
                pass: score.pass === "1",
                enabled_mods: getEnumMods(score.enabled_mods)
              });
            })
          });
        })
      }));
    });
  }
  /**
   * Makes a GET request to the `get_replay`
   * @param by Get replay by `score id` or `user & beatmap id`
   * @returns A string containing the Base64 encoded replay if the replay exists, otherwise null
   */
  getReplay(by, params) {
    return __async(this, null, function* () {
      var _a;
      let parsed = by === "score id" ? getReplayByScoreIdParamsSchema.parse(params) : getReplayByBeatmapAndUserIdParamsSchema.parse(params);
      let validParams = __spreadProps(__spreadValues({}, parsed), {
        m: parsed.m && ModesEnum[parsed.m],
        mods: getModsEnum((_a = parsed.mods) != null ? _a : [])
      });
      let replay = yield this.fetch("get_replay", validParams);
      return replay.error ? null : replay.content;
    });
  }
};

// src/utils/constants.ts
var buildUrl = {
  /**
   * Create a custom URL using the ppy.sh domain as a base
   * @param path Path to set after `https://{subdomain}.ppy.sh/`
   * @param subdomain Specify a subdomain to point to, defaults to `osu`
   */
  custom: createUrl,
  beatmapsetCover: (beatmapsetId) => createUrl(`beatmaps/${beatmapsetId}/covers/cover.jpg`, "assets"),
  beatmapsetThumbnail: (beatmapsetId) => createUrl(`thumb/${beatmapsetId}.jpg`, "b"),
  beatmap: (beatmapId) => createUrl(`b/${beatmapId}`),
  beatmapset: (beatmapsetId) => createUrl(`s/${beatmapsetId}`),
  userAvatar: (userId) => createUrl(`a/${userId}`, "s"),
  user: (userId) => createUrl(`u/${userId}`),
  score: (gamemode, scoreId) => createUrl(`scores/${gamemode}/${scoreId}`),
  forum: (forumId) => createUrl(`community/forums/${forumId}`),
  forumTopic: (topicId) => createUrl(`community/forums/topics/${topicId}`),
  room: (roomId) => createUrl(`multiplayer/rooms/${roomId}`),
  match: (matchId) => createUrl(`mp/${matchId}`),
  /**
   * @param clientId OAuth client ID
   * @param redirectUri OAuth redirect URI
   * @param scopes An array of OAuth scopes
   * @param state Data that will be returned when a temporary code is issued. It can be used to provide a token for protecting against cross-site request forgery attacks
   */
  authRequest: (clientId, redirectUri, scopes = ["identify"], state) => {
    let url = createUrl("oauth");
    url += "/authorize";
    url += `?client_id=${clientId}`;
    url += `&redirect_uri=${redirectUri}`;
    url += "&response_type=code";
    url += `&scope=${scopes.reduce((prev, scope) => `${prev}${scope} `, "")}`.trim();
    if (state) {
      url += `&state=${state}`;
    }
    return url;
  }
};
function createUrl(path, subdomain) {
  let baseUrl = "https://osu.ppy.sh/";
  if (subdomain) {
    baseUrl = baseUrl.replace("osu", subdomain);
  }
  return `${baseUrl}${path}`;
}
var calcAccuracy = {
  /**
   * Calculate accuracy for osu! standard
   * @param c300 300s
   * @param c100 100s
   * @param c50 50s
   * @param misses Misses
   */
  osu: (c300, c100, c50, misses) => {
    return (6 * c300 + 2 * c100 + c50) / (6 * (c300 + c100 + c50 + misses));
  },
  /**
   * Calculate accuracy for osu! taiko
   * @param geki Greats
   * @param katu Goods
   * @param misses Misses
   */
  taiko: (geki, katu, misses) => {
    return (2 * geki + katu) / (2 * (geki + katu + misses));
  },
  /**
   * Calculate accuracy for osu! catch
   * @param c300 Caught fruits
   * @param c100 Caught drops
   * @param c50 Caught droplets
   * @param katu Drops
   * @param misses Droplets
   */
  fruits: (c300, c100, c50, katu, misses) => {
    let x = c300 + c100 + c50;
    return x / (x + katu + misses);
  },
  /**
   * Calculate accuracy for osu! mania
   * @param geki Maxes
   * @param c300 300s
   * @param katu 200s
   * @param c100 100s
   * @param c50 50s
   * @param misses Misses
   * @param scoreV2 Apply score V2 formula?
   */
  mania: (geki, c300, katu, c100, c50, misses, scoreV2) => {
    let x = scoreV2 ? 305 * geki + 300 * c300 : 300 * (geki + c300);
    let y = scoreV2 ? 305 : 300;
    return (x + 200 * katu + 100 * c100 + 50 * c50) / (y * (geki + c300 + katu + c100 + c50 + misses));
  }
};
var calcModStat = {
  hr: {
    cs: (n) => n * 1.3,
    od: hrStat,
    ar: hrStat,
    hp: hrStat
  },
  dt: {
    od: (n) => (53 + 8 * n) / 12,
    bpm: (n) => n * 1.5,
    ar: (n) => Math.min(n <= 5 ? (75 + 8 * n) / 15 : (13 + 2 * n) / 3, 11),
    length: (n) => n / 1.5
  },
  ez: {
    cs: ezStat,
    od: ezStat,
    ar: ezStat,
    hp: ezStat
  },
  ht: {
    od: (n) => (-53 + 16 * n) / 12,
    bpm: (n) => n * 0.75,
    ar: (n) => n <= 5 ? 4 / 3 * n - 5 : n > 7 ? 4 / 3 * n - 13 / 3 : 4 / 3 * n - 19 / 3,
    length: (n) => n * 0.75
  }
};
function hrStat(n) {
  return Math.min(n * 1.4, 10);
}
function ezStat(n) {
  return n / 2;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Auth,
  AuthCodeGrant,
  Beatmaps,
  BeatmapsetDiscussions,
  Changelog,
  Chat,
  Client,
  Comments,
  Forum,
  GenresEnum,
  LanguagesEnum,
  LegacyClient,
  ModesEnum,
  ModsEnum,
  Multiplayer,
  News,
  Ranking,
  ScoringTypeEnum,
  StatusEnum,
  TeamColorEnum,
  TeamTypeEnum,
  Users,
  Wiki,
  buildUrl,
  calcAccuracy,
  calcModStat
});
